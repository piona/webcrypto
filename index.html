<!DOCTYPE html>
<html>
  <head>
    <title>WebCrypto</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=2">
    <style>
      body {
        font-family: sans;
        width: 960px;
        margin: 0 auto;
      }

      textarea {
        font-family: monospace;
        width: 100%;
        padding: 5px;
        box-sizing: border-box;
      }

      .tab {
        overflow: hidden;
        background-color: #f1f1f1;
      }

      .tab button {
        background-color: inherit;
        float: left;
        border: none;
        outline: none;
        cursor: pointer;
        padding: 6px 8px;
        transition: 0.3s;
        font-size: 18px;
      }

      .tab button:hover {
        background-color: #ddd;
      }

      .tab button.active {
        background-color: #bbb;
      }

      .tabcontent {
        display: none;
        padding: 6px 12px;
      }
    </style>
  </head>
  <body onload="showTab(event, 'defaultTab')">
    <div class="tab">
      <button class="tablinks" onclick="showTab(event, 'encodingTab')">Encoding</button>
      <button class="tablinks" onclick="showTab(event, 'otpTab')">OTP</button>
      <button class="tablinks" onclick="showTab(event, 'keyshareTab')">Keyshare</button>
      <button class="tablinks" onclick="showTab(event, 'aesTab')">AES</button>
      <button class="tablinks" onclick="showTab(event, 'shaTab')">SHA</button>
      <button class="tablinks" onclick="showTab(event, 'hmacTab')">HMAC</button>
      <button class="tablinks" onclick="showTab(event, 'ecdsaTab')">ECDSA</button>
      <button class="tablinks" onclick="showTab(event, 'ecdhTab')">ECDH</button>
    </div>

    <div id ="defaultTab" class="tabcontent">
      <h3>Welcome to WebCrypto!</h3>
      <p>
        This page uses the Web Cryptography API to demonstrate some cryptographic operations.
      </p>
      <p>
        Supplementary resources
        <ul>
          <li><a href="https://www.w3.org/TR/WebCryptoAPI/">Web Cryptography API, W3C Recommendation</a></li>
          <li><a href="https://diafygi.github.io/webcrypto-examples/">Web Cryptography API Live Table</a> with
            <a href="https://github.com/diafygi/webcrypto-examples/">samples</a></li>
          <li>this page <a href="https://github.com/piona/webcrypto">sources</a></li>
        </ul>
      </p>
    </div>

    <div id="encodingTab" class="tabcontent">
      <form id="encoding">
        <p><b>UTF-8</b><br/>
          <textarea id="utf-8" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <p><b>Hexadecimal</b><br/>
          <textarea id="hex" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <p><b>Base64</b><br/>
          <textarea id="base64" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <p><b>Base64URL</b><br/>
          <textarea id="base64url" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <input type="button" value="clear all"
                             onclick="
                             document.getElementById('encoding').elements['utf-8'].value = '';
                             document.getElementById('encoding').elements['hex'].value = '';
                             document.getElementById('encoding').elements['base64'].value = '';
                             document.getElementById('encoding').elements['base64url'].value = '';"/>
      </form>

      <script>
        // reencode data to output fields
        function reencodeData(evt) {
          let data = evt.srcElement.value;
          let dataEnc = evt.srcElement.id;

          evt.srcElement.form.elements["utf-8"].value = data;
          evt.srcElement.form.elements["hex"].value = data;
          evt.srcElement.form.elements["base64"].value = data;
          evt.srcElement.form.elements["base64url"].value = data;

          switchDataEnc(evt, "utf-8", dataEnc, "utf-8");
          switchDataEnc(evt, "hex", dataEnc, "hex");
          switchDataEnc(evt, "base64", dataEnc, "base64");
          switchDataEnc(evt, "base64url", dataEnc, "base64url");
        }
      </script>
    </div>

    <div id="otpTab" class="tabcontent">
      <form id="otp">
        <p><b>Input</b>
          <input type="radio" name="plainEnc" value="utf-8" onclick="switchDataEnc(event, 'plain');"/> utf-8
          <input type="radio" name="plainEnc" value="hex" checked onclick="switchDataEnc(event, 'plain');"/> hex
          <input type="radio" name="plainEnc" value="base64" onclick="switchDataEnc(event, 'plain');" /> base64
          <input type="radio" name="plainEnc" value="base64url" onclick="switchDataEnc(event, 'plain');"/> base64url
          <br/>
          <textarea id="plain" rows="5" oninput="otpEncryptAuto(event);"></textarea>
          <br/>
          <input type="button" value="clear"
                               onclick="document.getElementById('otp').elements['plain'].value = '';
                               otpEncryptAuto(event);"/>
          <input type="button" value="hello world"
                               onclick="document.getElementById('otp').elements['plain'].value = 'hello world';
                               switchDataEnc(event, 'plain', 'utf-8', document.getElementById('otp').elements['plainEnc'].value);
                               otpEncryptAuto(event);"/>
        </p>
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="5" oninput="otpEncryptAuto(event);"></textarea>
          <br/>
          <input type="button" value="clear" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="fix length" onclick="otpKey(event);"/>
          <input type="button" value="generate" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="0x00" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="0xff" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="hello world" onclick="otpKey(event); otpEncryptAuto(event);"/>
        </p>
        <p>
          <input id="crypt" type="button" value="encrypt/decrypt" onclick="otpEncrypt(event);" disabled/>
          <input id="auto" type="checkbox" checked onclick="xorToggleUpdate(event);"/> auto
        </p>
        <p id="output">
          <b>Output</b>
          <input type="radio" name="cipherEnc" value="utf-8" onclick="switchDataEnc(event, 'cipher');"/> utf-8
          <input type="radio" name="cipherEnc" value="hex" checked onclick="switchDataEnc(event, 'cipher');"/> hex
          <input type="radio" name="cipherEnc" value="base64" onclick="switchDataEnc(event, 'cipher');"/> base64
          <input type="radio" name="cipherEnc" value="base64url" onclick="switchDataEnc(event, 'cipher');"/> base64url
          <textarea id="cipher" rows="5" readonly></textarea>
          <input type="button" value="copy as input"
                               onclick="document.getElementById('otp').elements['plain'].value = document.getElementById('otp').elements['cipher'].value;
                               otpEncryptAuto(event);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        // run otp algorithm using xor
        function otpEncrypt(evt) {
          const currentPlainEnc = evt.srcElement.form.getAttribute("plainCurrentEnc");
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");
          const currentCipherEnc = evt.srcElement.form.getAttribute("cipherCurrentEnc");

          let plain = evt.srcElement.form.elements["plain"].value;
          console.log("Plain as " + currentPlainEnc + ": " + plain);

          let plainBytes = toBytes(plain, currentPlainEnc);
          console.log("Plain: " + plainBytes);

          if (plainBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad plain data");
            return;
          }

          let key = evt.srcElement.form.elements["key"].value;
          console.log("Key as " + currentKeyEnc + ": " + key);

          let keyBytes = toBytes(key, currentKeyEnc);
          console.log("Key: " + keyBytes);

          if (keyBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad key data");
            return;
          }

          let cipher = xorBytes(plainBytes, keyBytes);

          console.log("Cipher encoding: " + currentCipherEnc);
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(cipher)), currentCipherEnc);
          console.log("Cipher: " + cipher);
          console.log("Cipher as " + currentCipherEnc + ": " + value);

          evt.srcElement.form.elements["cipher"].value = value;
        }

        // calculate otp if auto update is active
        function otpEncryptAuto(evt) {
          if (!evt.srcElement.form.elements["auto"].checked) {
            return;
          }
          otpEncrypt(evt);
        }

        function otpKey(evt) {
          // some switch cases ended with return
          switch (evt.srcElement.value) {
            case "clear":
              evt.srcElement.form.elements["key"].value = "";
              return;
            case "0x00":
              evt.srcElement.form.elements["key"].value = "00";
              switchDataEnc(evt, "key", "hex", evt.srcElement.form.elements['keyEnc'].value);
              break;
            case "0xff":
              evt.srcElement.form.elements["key"].value = "ff";
              switchDataEnc(evt, "key", "hex", evt.srcElement.form.elements['keyEnc'].value);
              break;
            case "hello world":
              evt.srcElement.form.elements["key"].value = "hello world";
              switchDataEnc(evt, "key", "utf-8", evt.srcElement.form.elements['keyEnc'].value);
              return;
            case "fix length":
            case "generate":
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              return;
          }

          // fix key length
          const currentPlainEnc = evt.srcElement.form.getAttribute("plainCurrentEnc");
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");
          const currentCipherEnc = evt.srcElement.form.getAttribute("cipherCurrentEnc");

          let plain = evt.srcElement.form.elements["plain"].value;
          console.log("Plain as " + currentPlainEnc + ": " + plain);

          let plainBytes = toBytes(plain, currentPlainEnc);
          console.log("Plain: " + plainBytes);

          if (plainBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad plain data");
            return;
          }

          let key = evt.srcElement.form.elements["key"].value;
          console.log("Key as " + currentKeyEnc + ": " + key);

          let keyBytes = toBytes(key, currentKeyEnc);
          console.log("Key: " + keyBytes);

          if (evt.srcElement.value == "generate") {
            keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(plainBytes.length)));
          }

          if (keyBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad key data");
            return;
          }

          let keyBytesFixed = [];
          for (let i = 0; i < plainBytes.length; i++) {
            keyBytesFixed.push(keyBytes[i % keyBytes.length]);
          }

          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(keyBytesFixed)), currentKeyEnc);
          evt.srcElement.form.elements["key"].value = value;
        }

        // enable/disable update button
        function xorToggleUpdate(evt) {
          if (evt.srcElement.form.elements["auto"].checked) {
            evt.srcElement.form.elements["crypt"].disabled = true;
          } else {
            evt.srcElement.form.elements["crypt"].disabled = false;
          }
        }

        // initialize fields
        document.getElementById("otp").setAttribute("plain" + "CurrentEnc", "hex");
        document.getElementById("otp").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("otp").setAttribute("cipher" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="keyshareTab" class="tabcontent">
      <form id="keyshare">
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="3"></textarea>
          <br/>
          <input type="button" value="clear" onclick="keyshareKey(event);"/>
          <input type="button" value="128 bit" onclick="keyshareKey(event);"/>
          <input type="button" value="192 bit" onclick="keyshareKey(event);"/>
          <input type="button" value="256 bit" onclick="keyshareKey(event);"/>
        </p>
        <p>
          <b>Shares: <span id="keyshareShares">3</span></b><br/>
          <input type="range" id="shares" name="shares" min="1" max="16" step="1" value="3" onchange="keyshareUpdateValue(event);"/>
          <textarea id="share" rows="16"></textarea>
          <br/>
          <input type="button" value="clear" onclick="document.getElementById('keyshare').elements['share'].value = '';"/>
          <input type="button" value="split" onclick="keyshareSplit(event);"/>
          <input type="button" value="combine" onclick="keyshareCombine(event);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        // run keyshare split algorithm
        function keyshareSplit(evt) {
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");

          let key = evt.srcElement.form.elements["key"].value;
          console.log("Key as " + currentKeyEnc + ": " + key);

          let keyBytes = toBytes(key, currentKeyEnc);
          console.log("Key: " + keyBytes);

          if (keyBytes == null) {
            evt.srcElement.form.elements["shares"].value = "";
            setStatus("keyshareTab", 0, "<b>error</b>: bad key data");
            return;
          }

          let shares = evt.srcElement.form.elements["shares"].value;
          console.log("Shares: " + shares);

          let xorValue = uint8ArrayToBytes(new Uint8Array(keyBytes.length));

          let value = "";

          // n - 1 random components
          while (shares - 1 > 0) {
            let component = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(keyBytes.length)));
            xorValue = xorBytes(xorValue, component);
            value += fromBytes(component, currentKeyEnc) + "\n";
            shares--;
          }
          // final component
          xorValue = xorBytes(xorValue, keyBytes);
          value += fromBytes(xorValue, currentKeyEnc);

          evt.srcElement.form.elements["share"].value = value;
        }

        // run keyshare combine algorithm
        function keyshareCombine(evt) {
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");

          let components = evt.srcElement.form.elements["share"].value.split("\n");

          // first component
          let xorValue = toBytes(components[0], currentKeyEnc);

          // n - 1 components
          for (let i = 1; i < components.length; i++) {
            let component = toBytes(components[i], currentKeyEnc);
            xorValue = xorBytes(xorValue, component);
          }

          let value = fromBytes(xorValue, currentKeyEnc);

          evt.srcElement.form.elements["key"].value = value;
        }

        function keyshareKey(evt) {
          // some switch cases ended with return
          let keyBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "128 bit":
              keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(16)));
              break;
            case "192 bit":
              keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(24)));
              break;
            case "256 bit":
              keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(32)));
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              return;
          }

          // convert key
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(keyBytes)), currentKeyEnc);
          evt.srcElement.form.elements["key"].value = value;
        }

        // update key shares value from input range
        function keyshareUpdateValue(evt) {
          document.getElementById("keyshareTab").querySelector("#keyshareShares").innerHTML = evt.srcElement.value;
        }

        // initialize fields
        document.getElementById("keyshare").setAttribute("key" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="aesTab" class="tabcontent">
      <form id="aes">
        <p><b>Mode</b>
          <input type="radio" name="mode" value="ECB" checked onclick="aesMode(event);"/> ECB
          <input type="radio" name="mode" value="CBC" onclick="aesMode(event);"/> CBC
          <input type="radio" name="mode" value="CTR" onclick="aesMode(event);"/> CTR
          <input type="radio" name="mode" value="GCM" onclick="aesMode(event);"/> GCM
          <br/>
        </p>
        <span id="aesPadding">
          <p><b>Padding</b>
            <input type="radio" name="padding" value="None" checked/> None
            <input type="radio" name="padding" value="PKCS #7"/> PKCS #7
            <br/>
          </p>
        </span>
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="aesParams(event, 'key');"/>
          <input type="button" value="128 bit" onclick="aesParams(event, 'key');"/>
          <input type="button" value="192 bit" onclick="aesParams(event, 'key');"/>
          <input type="button" value="256 bit" onclick="aesParams(event, 'key');"/>
          <input type="button" value="key #1" onclick="aesParams(event, 'key');"/>
          <input type="button" value="key #2" onclick="aesParams(event, 'key');"/>
        </p>
        <span id="aesParam" hidden>
          <p><b><span id="aesParamName"></span></b>
            <input type="radio" name="paramEnc" value="utf-8" onclick="switchDataEnc(event, 'param');"/> utf-8
            <input type="radio" name="paramEnc" value="hex" checked onclick="switchDataEnc(event, 'param');"/> hex
            <input type="radio" name="paramEnc" value="base64" onclick="switchDataEnc(event, 'param');" /> base64
            <input type="radio" name="paramEnc" value="base64url" onclick="switchDataEnc(event, 'param');"/> base64url
            <br/>
            <textarea id="param" rows="2"></textarea>
            <br/>
            <input type="button" value="clear" onclick="aesParams(event, 'param');"/>
            <input type="button" value="96 bit" onclick="aesParams(event, 'param');"/>
            <input type="button" value="128 bit" onclick="aesParams(event, 'param');"/>
            <input type="button" value="128 zero bit" onclick="aesParams(event, 'param');"/>
            <input type="button" value="param #1" onclick="aesParams(event, 'param');"/>
            <input type="button" value="param #2" onclick="aesParams(event, 'param');"/>
          </p>
        </span>
        <p><b>Input</b>
          <input type="radio" name="inputEnc" value="utf-8" onclick="switchDataEnc(event, 'input');"/> utf-8
          <input type="radio" name="inputEnc" value="hex" checked onclick="switchDataEnc(event, 'input');"/> hex
          <input type="radio" name="inputEnc" value="base64" onclick="switchDataEnc(event, 'input');" /> base64
          <input type="radio" name="inputEnc" value="base64url" onclick="switchDataEnc(event, 'input');"/> base64url
          <br/>
          <textarea id="input" rows="5"></textarea>
          <br/>
          <input type="button" value="clear" onclick="aesParams(event, 'input');"/>
          <input type="button" value="one block" onclick="aesParams(event, 'input');"/>
          <input type="button" value="two blocks" onclick="aesParams(event, 'input');"/>
          <input type="button" value="hex block split" onclick="hexSplit(event, 'input', 16);"/>
        </p>
        <span id="aesAdditionalData" hidden>
          <p><b>Additional data</b>
            <input type="radio" name="aadEnc" value="utf-8" onclick="switchDataEnc(event, 'aad');"/> utf-8
            <input type="radio" name="aadEnc" value="hex" checked onclick="switchDataEnc(event, 'aad');"/> hex
            <input type="radio" name="aadEnc" value="base64" onclick="switchDataEnc(event, 'aad');" /> base64
            <input type="radio" name="aadEnc" value="base64url" onclick="switchDataEnc(event, 'aad');"/> base64url
            <br/>
            <textarea id="aad" rows="5"></textarea>
            <br/>
            <input type="button" value="clear" onclick="document.getElementById('aes').elements['aad'].value = '';"/>
            <input type="button" value="hello world"
                                 onclick="document.getElementById('aes').elements['aad'].value = this.value;
                                 switchDataEnc(event, 'aad', 'utf-8', document.getElementById('aes').elements['aadEnc'].value);"/>
            <input type="button" value="some data"
                                 onclick="document.getElementById('aes').elements['aad'].value = this.value;
                                 switchDataEnc(event, 'aad', 'utf-8', document.getElementById('aes').elements['aadEnc'].value);"/>
          </p>
        </span>
        <p>
          <input id="encrypt" type="button" value="encrypt" onclick="aesCrypt(event);"/>
          <input id="decrypt" type="button" value="decrypt" onclick="aesCrypt(event);"/>
        </p>
        <p>
          <b>Output</b>
          <input type="radio" name="outputEnc" value="utf-8" onclick="switchDataEnc(event, 'output');"/> utf-8
          <input type="radio" name="outputEnc" value="hex" checked onclick="switchDataEnc(event, 'output');"/> hex
          <input type="radio" name="outputEnc" value="base64" onclick="switchDataEnc(event, 'output');"/> base64
          <input type="radio" name="outputEnc" value="base64url" onclick="switchDataEnc(event, 'output');"/> base64url
          <textarea id="output" rows="5" readonly></textarea>
          <br/>
          <input type="button" value="copy as input"
                               onclick="document.getElementById('aes').elements['input'].value = document.getElementById('aes').elements['output'].value;"/>
          <input type="button" value="hex split" onclick="hexSplit(event, 'output', 16);"/>
          <span class="status"></span>
        </p>
        <span id="aesAuthTag" hidden>
          <p><b>Auth tag length</b>
            <input type="radio" name="authTagLength" value="128" checked/> 128
            <input type="radio" name="authTagLength" value="64"/> 64
            <input type="radio" name="authTagLength" value="120"/> 120
            <input type="radio" name="authTagLength" value="112"/> 112
            <input type="radio" name="authTagLength" value="104"/> 104
            <input type="radio" name="authTagLength" value="96"/> 96
            <input type="radio" name="authTagLength" value="32"/> 32
            <br/>
          </p>
          <p><b>Auth tag</b>
            <input type="radio" name="authTagEnc" value="utf-8" onclick="switchDataEnc(event, 'authTag');"/> utf-8
            <input type="radio" name="authTagEnc" value="hex" checked onclick="switchDataEnc(event, 'authTag');"/> hex
            <input type="radio" name="authTagEnc" value="base64" onclick="switchDataEnc(event, 'authTag');"/> base64
            <input type="radio" name="authTagEnc" value="base64url" onclick="switchDataEnc(event, 'authTag');"/> base64url
            <br/>
            <textarea id="authTag" rows="2"></textarea>
            <br/>
            <input type="button" value="clear"
                                 onclick="document.getElementById('aes').elements['authTag'].value = '';"/>
            <input type="button" value="128 bit"
                                 onclick="aesParams(event, 'authTag');"/>
            <input type="button" value="cut"
                                 onclick="truncData(event, 'authTag', document.getElementById('aes').elements['authTagLength'].value / 8);"/>
          </p>
        </span>
      </form>

      <script>
        // show/hide fields when switching mode of operation
        function aesMode(evt) {
          console.log("AES mode: " + evt.srcElement.value);
          let aesTab = document.getElementById("aesTab");
          switch (evt.srcElement.value) {
            case "ECB":
              // padding
              aesTab.querySelector("#aesPadding").removeAttribute("hidden");
              // param
              aesTab.querySelector("#aesParam").setAttribute("hidden", undefined);
              // additional data
              aesTab.querySelector("#aesAdditionalData").setAttribute("hidden", undefined);
              aesTab.querySelector("#aesAuthTag").setAttribute("hidden", undefined);
              break;
            case "CBC":
              // padding
              aesTab.querySelector("#aesPadding").removeAttribute("hidden");
              // param
              aesTab.querySelector("#aesParam").removeAttribute("hidden");
              aesTab.querySelector("#aesParamName").innerHTML = "IV";
              // additional data
              aesTab.querySelector("#aesAdditionalData").setAttribute("hidden", undefined);
              aesTab.querySelector("#aesAuthTag").setAttribute("hidden", undefined);
              break;
            case "CTR":
              // padding
              aesTab.querySelector("#aesPadding").setAttribute("hidden", undefined);
              // param
              aesTab.querySelector("#aesParam").removeAttribute("hidden");
              aesTab.querySelector("#aesParamName").innerHTML = "Counter";
              // additional data and tag
              aesTab.querySelector("#aesAdditionalData").setAttribute("hidden", undefined);
              aesTab.querySelector("#aesAuthTag").setAttribute("hidden", undefined);
              break;
            case "GCM":
              // padding
              aesTab.querySelector("#aesPadding").setAttribute("hidden", undefined);
              // param
              aesTab.querySelector("#aesParam").removeAttribute("hidden");
              aesTab.querySelector("#aesParamName").innerHTML = "Nonce";
              // additional data and tag
              aesTab.querySelector("#aesAdditionalData").removeAttribute("hidden");
              aesTab.querySelector("#aesAuthTag").removeAttribute("hidden");
              break;
            default:
              return;
          }
        }

        function aesParams(evt, target) {
          let paramBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "128 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(16)));
              break;
            case "192 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(24)));
              break;
            case "256 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(32)));
              break;
            case "key #1":
              paramBytes = hexToBytes("6745486a2ee2b58ddb5578b4777e9f13");
              break;
            case "key #2":
              paramBytes = hexToBytes("ead670026e84e4a6c3fd5ebcff381e3cbedf508c80d1342bb9778ec599143f8f");
              break;
            case "96 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(12)));
              break;
            case "param #1":
              paramBytes = hexToBytes("91f916f7b17ecdec0103d690");
              break;
            case "param #2":
              paramBytes = hexToBytes("f10a6dfb41d70df1832eb3df12fb663a");
              break;
            case "128 zero bit":
            case "one block":
              paramBytes = uint8ArrayToBytes(new Uint8Array(16));
              break;
            case "two blocks":
              paramBytes = uint8ArrayToBytes(new Uint8Array(32));
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(paramBytes)), currentParamEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // perform aes encryption/decryption
        async function aesCrypt(evt) {
          evt.srcElement.form.elements["output"].value = "";

          const oper = evt.srcElement.value;
          console.log("Operation: " + oper);

          const mode = evt.srcElement.form.elements["mode"].value;
          console.log("Mode: " + mode);

          const padding = evt.srcElement.form.elements["padding"].value;
          console.log("Padding: " + padding);

          // read and import AES key
          const keyBytes = toBytes(evt.srcElement.form.elements["key"].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));

          // import raw key
          const aesKey = await window.crypto.subtle.importKey(
            "raw",
            bytesToUint8Array(keyBytes),
            "AES-" + (mode == "ECB" ? "CBC" : mode),
            true,
            ["encrypt", "decrypt"]
          ).then(function(key) {
            return key;
          }).catch(function(err) {
            evt.srcElement.form.elements["output"].value = "";
            setStatus("aesTab", 0, "<b>error</b>: " + err);
          });

          if (aesKey == null) {
            return;
          }

          // read input, param and additional data
          let inputBytes = toBytes(evt.srcElement.form.elements["input"].value, evt.srcElement.form.getAttribute("inputCurrentEnc"));
          let paramBytes = toBytes(evt.srcElement.form.elements["param"].value, evt.srcElement.form.getAttribute("paramCurrentEnc"));
          let aadBytes = toBytes(evt.srcElement.form.elements["aad"].value, evt.srcElement.form.getAttribute("aadCurrentEnc"));
          let authTagBytes = toBytes(evt.srcElement.form.elements["authTag"].value, evt.srcElement.form.getAttribute("authTagCurrentEnc"));
          let authTagLength = evt.srcElement.form.elements["authTagLength"].value / 8;

          if ((mode == "ECB" || mode == "CBC") && (padding == "None" || oper == "decrypt")) {
            if (inputBytes == null || inputBytes.length == 0 || inputBytes.length % 16 != 0) {
              evt.srcElement.form.elements["output"].value = "Bad input: must be multiple of 16 bytes";
              return;
            }
          }

          let output = [];
          console.log("inputBytes length = " + inputBytes.length);

          if (mode == "ECB" && oper == "encrypt") { // ECB = use CBC mode for each block
            for (let i = 0; i <= inputBytes.length; i += 16) {
              if (padding == "None" && i == inputBytes.length) {
                break;
              }
              let block = new Uint8Array(inputBytes.slice(i, i + 16));
              const encryptedBlock = await window.crypto.subtle.encrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                block
              ).then(function(encrypted) {
                return encrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              if (encryptedBlock == null) {
                return;
              }
              output = output.concat(uint8ArrayToBytes(new Uint8Array(encryptedBlock, 0, 16)));
            }
          } else if (mode == "ECB" && oper == "decrypt") {
            for (let i = 0; i < inputBytes.length; i += 16) {
              // prepare empty padding
              const emptyPadding = await window.crypto.subtle.encrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                new Uint8Array(xorBytes(uint8ArrayToBytes(new Uint8Array(Array(16).fill(16))), inputBytes.slice(i, i + 16)))
              ).then(function(encrypted) {
                return encrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              console.log(emptyPadding);
              let emptyPaddingBytes = uint8ArrayToBytes(new Uint8Array(emptyPadding, 0, 16))

              let block = [];
              if (i != inputBytes.length - 16) {
                block = new Uint8Array(inputBytes.slice(i, i + 16).concat(emptyPaddingBytes));
              } else {
                if (padding == "None") {
                  block = new Uint8Array(inputBytes.slice(i, i + 16).concat(emptyPaddingBytes));
                } else {
                  block = new Uint8Array(inputBytes.slice(i, i + 16));
                }
              }
              const decryptedBlock = await window.crypto.subtle.decrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                block
              ).then(function(decrypted) {
                return decrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              if (decryptedBlock == null) {
                return;
              }

              if (decryptedBlock.length > 16) {
                output = output.concat(uint8ArrayToBytes(new Uint8Array(decryptedBlock, 0, 16)));
              } else {
                output = output.concat(uint8ArrayToBytes(new Uint8Array(decryptedBlock)));
              }
            }
          } else if (mode == "CBC" && oper == "encrypt") {
            let blocks = new Uint8Array(inputBytes);
            const encryptedBlocks = await window.crypto.subtle.encrypt(
              {
                name: "AES-CBC",
                iv: new Uint8Array(paramBytes),
              },
              aesKey,
              blocks
            ).then(function(encrypted) {
              return encrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (encryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(encryptedBlocks));
            if (padding == "None") {
              output = output.slice(0, output.length - 16);
            }
          } else if (mode == "CBC" && oper == "decrypt") {
            // prepare empty padding
            if (padding == "None") {
              const emptyPadding = await window.crypto.subtle.encrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                new Uint8Array(xorBytes(uint8ArrayToBytes(new Uint8Array(Array(16).fill(16))), inputBytes.slice(inputBytes.length - 16, inputBytes.length)))
              ).then(function(encrypted) {
                return encrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              console.log(emptyPadding);
              let emptyPaddingBytes = uint8ArrayToBytes(new Uint8Array(emptyPadding, 0, 16))
              inputBytes = inputBytes.concat(emptyPaddingBytes);
            }
            let blocks = new Uint8Array(inputBytes);
            const decryptedBlocks = await window.crypto.subtle.decrypt(
              {
                name: "AES-CBC",
                iv: new Uint8Array(paramBytes),
              },
              aesKey,
              blocks
            ).then(function(decrypted) {
              return decrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (decryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(decryptedBlocks));
          } else if (mode == "CTR" && oper == "encrypt") {
            let blocks = new Uint8Array(inputBytes);
            const encryptedBlocks = await window.crypto.subtle.encrypt(
              {
                name: "AES-CTR",
                counter: new Uint8Array(paramBytes),
                length: 128
              },
              aesKey,
              blocks
            ).then(function(encrypted) {
              return encrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (encryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(encryptedBlocks));
          } else if (mode == "CTR" && oper == "decrypt") {
            let blocks = new Uint8Array(inputBytes);
            const decryptedBlocks = await window.crypto.subtle.decrypt(
              {
                name: "AES-CTR",
                counter: new Uint8Array(paramBytes),
                length: 128
              },
              aesKey,
              blocks
            ).then(function(decrypted) {
              return decrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (decryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(decryptedBlocks));
          } else if (mode == "GCM" && oper == "encrypt") {
            let blocks = new Uint8Array(inputBytes);
            const encryptedBlocks = await window.crypto.subtle.encrypt(
              {
                name: "AES-GCM",
                iv: new Uint8Array(paramBytes),
                tagLength: authTagLength * 8,
                additionalData: new Uint8Array(aadBytes)
              },
              aesKey,
              blocks
            ).then(function(encrypted) {
              return encrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (encryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(encryptedBlocks));
            authTagBytes = output.slice(output.length - authTagLength, output.length);
            output = output.slice(0, output.length - authTagLength);
          } else if (mode == "GCM" && oper == "decrypt") {
            inputBytes = inputBytes.concat(authTagBytes);
            let blocks = new Uint8Array(inputBytes);
            const decryptedBlocks = await window.crypto.subtle.decrypt(
              {
                name: "AES-GCM",
                iv: new Uint8Array(paramBytes),
                tagLength: authTagLength * 8,
                additionalData: new Uint8Array(aadBytes)
              },
              aesKey,
              blocks
            ).then(function(decrypted) {
              return decrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (decryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(decryptedBlocks));
          }

          let value = fromBytes(output, evt.srcElement.form.getAttribute("outputCurrentEnc"));
          evt.srcElement.form.elements["output"].value = value;

          if (authTag != null) {
            value = fromBytes(authTagBytes, evt.srcElement.form.getAttribute("authTagCurrentEnc"));
            evt.srcElement.form.elements["authTag"].value = value;
          }
        }

        // initialize fields
        document.getElementById("aes").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("param" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("input" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("aad" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("output" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("authTag" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="shaTab" class="tabcontent">
      <form id="sha">
        <p><b>SHA</b>
          <input type="radio" name="alg" value="SHA-256" checked onclick="shaHashAuto(event);"/> SHA-256
          <input type="radio" name="alg" value="SHA-384" onclick="shaHashAuto(event);"/> SHA-384
          <input type="radio" name="alg" value="SHA-512" onclick="shaHashAuto(event);"/> SHA-512
          <input type="radio" name="alg" value="SHA-1" onclick="shaHashAuto(event);"/> SHA-1
          <br/>
        </p>
        <p><b>Data</b>
          <input type="radio" name="dataEnc" value="utf-8" checked onclick="switchDataEnc(event, 'data');"/> utf-8
          <input type="radio" name="dataEnc" value="hex" onclick="switchDataEnc(event, 'data');"/> hex
          <input type="radio" name="dataEnc" value="base64" onclick="switchDataEnc(event, 'data');"/> base64
          <input type="radio" name="dataEnc" value="base64url" onclick="switchDataEnc(event, 'data');"/> base64url
          <br/>
          <textarea id="data" rows="10" oninput="shaHashAuto(event);"></textarea>
          <br/>
          <input type="button" value="clear"
                               onclick="document.getElementById('sha').elements['data'].value = '';
                               shaHashAuto(event);"/>
          <input type="button" value="hello world"
                               onclick="document.getElementById('sha').elements['data'].value = 'hello world';
                               switchDataEnc(event, 'data', 'utf-8', document.getElementById('sha').elements['dataEnc'].value);
                               shaHashAuto(event);"/>
        </p>
        <p>
          <input id="update" type="button" value="update" onclick="shaHash(event);" disabled/>
          <input id="auto" type="checkbox" checked onclick="shaToggleUpdate(event);"/> auto
        </p>
        <p>
          <b>Hash</b>
          <input type="radio" name="hashEnc" value="utf-8" onclick="switchDataEnc(event, 'hash');"/> utf-8
          <input type="radio" name="hashEnc" value="hex" checked onclick="switchDataEnc(event, 'hash');"/> hex
          <input type="radio" name="hashEnc" value="base64" onclick="switchDataEnc(event, 'hash');"/> base64
          <input type="radio" name="hashEnc" value="base64url" onclick="switchDataEnc(event, 'hash');"/> base64url
          <textarea id="hash" rows="2" readonly></textarea>
          <br/>
          <input type="button" value="copy as data"
                               onclick="document.getElementById('sha').elements['data'].value = document.getElementById('sha').elements['hash'].value;
                               shaHashAuto(event);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        // calculate hash value
        function shaHash(evt) {
          const currentDataEnc = evt.srcElement.form.getAttribute("dataCurrentEnc");
          const currentHashEnc = evt.srcElement.form.getAttribute("hashCurrentEnc");
          const alg = evt.srcElement.form.elements["alg"].value;
          console.log("Algorithm: " + alg);

          let value = evt.srcElement.form.elements["data"].value;
          console.log("Data as " + currentDataEnc + ": " + value);

          let bytes = toBytes(value, currentDataEnc);
          console.log("Data: " + bytes);

          if (bytes == null) {
            evt.srcElement.form.elements["hash"].value = "";
            setStatus("shaTab", 0, "<b>error</b>: bad input data");
            return;
          }

          window.crypto.subtle.digest(
            {
              name: alg
            },
            bytesToUint8Array(bytes)
          ).then(function(hash) {
            console.log("Hash encoding: " + currentHashEnc);
            let value = fromBytes(uint8ArrayToBytes(new Uint8Array(hash)), currentHashEnc);
            console.log("Hash: " + hash);
            console.log("Hash as " + currentHashEnc + ": " + value);

            evt.srcElement.form.elements["hash"].value = value;
          }).catch(function(err) {
            console.error(err);
          });
        }

        // calculate hash if auto update is active
        function shaHashAuto(evt) {
          if (!evt.srcElement.form.elements["auto"].checked) {
            return;
          }
          shaHash(evt);
        }

        // enable/disable update button
        function shaToggleUpdate(evt) {
          if (evt.srcElement.form.elements["auto"].checked) {
            evt.srcElement.form.elements["update"].disabled = true;
          } else {
            evt.srcElement.form.elements["update"].disabled = false;
          }
        }

        // initialize fields
        document.getElementById("sha").setAttribute("data" + "CurrentEnc", "utf-8");
        document.getElementById("sha").setAttribute("hash" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="hmacTab" class="tabcontent">
      <form id="hmac">
        <p><b>HMAC</b>
          <input type="radio" name="alg" value="SHA-256" checked/> SHA-256
          <input type="radio" name="alg" value="SHA-384"/> SHA-384
          <input type="radio" name="alg" value="SHA-512"/> SHA-512
          <input type="radio" name="alg" value="SHA-1"/> SHA-1
          <br/>
        </p>
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="128 bit" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="192 bit" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="256 bit" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="key #1" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="key #2" onclick="hmacParams(event, 'key');"/>
        </p>
        <p><b>Data</b>
          <input type="radio" name="dataEnc" value="utf-8" checked onclick="switchDataEnc(event, 'data');"/> utf-8
          <input type="radio" name="dataEnc" value="hex" onclick="switchDataEnc(event, 'data');"/> hex
          <input type="radio" name="dataEnc" value="base64" onclick="switchDataEnc(event, 'data');"/> base64
          <input type="radio" name="dataEnc" value="base64url" onclick="switchDataEnc(event, 'data');"/> base64url
          <br/>
          <textarea id="data" rows="10"></textarea>
          <br/>
          <input type="button" value="clear" onclick="hmacParams(event, 'data');"/>
          <input type="button" value="hello world" onclick="hmacParams(event, 'data');"/>
        </p>
        <p>
          <input id="sign" type="button" value="sign" onclick="hmac(event);"/>
          <input id="verify" type="button" value="verify" onclick="hmac(event);"/>
        </p>
        <p>
          <b>HMAC</b>
          <input type="radio" name="hashEnc" value="utf-8" onclick="switchDataEnc(event, 'hash');"/> utf-8
          <input type="radio" name="hashEnc" value="hex" checked onclick="switchDataEnc(event, 'hash');"/> hex
          <input type="radio" name="hashEnc" value="base64" onclick="switchDataEnc(event, 'hash');"/> base64
          <input type="radio" name="hashEnc" value="base64url" onclick="switchDataEnc(event, 'hash');"/> base64url
          <textarea id="hash" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="160 bit" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="256 bit" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="384 bit" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="512 bit" onclick="hmacParams(event, 'hash');"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        function hmacParams(evt, target) {
          let paramBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "128 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(16)));
              break;
            case "160 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(20)));
              break;
            case "192 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(24)));
              break;
            case "256 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(32)));
              break;
            case "384 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(48)));
              break;
            case "512 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(64)));
              break;
            case "key #1":
              paramBytes = hexToBytes("250a9def94c78a02c141b37387a6190f");
              break;
            case "key #2":
              paramBytes = hexToBytes("f9c15df9095732493c18e959f2933d7a37391bae2c7dd85e1f0e0ca45a5913cd");
              break;
            case "hello world":
              paramBytes = toBytes("hello world", "utf-8");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(paramBytes)), currentParamEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // calculate hash value
        async function hmac(evt) {
          const alg = evt.srcElement.form.elements["alg"].value;
          console.log("Algorithm: " + alg);

          const currentHashEnc = evt.srcElement.form.getAttribute("hashCurrentEnc");

          let keyBytes = toBytes(evt.srcElement.form.elements["key"].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));
          let dataBytes = toBytes(evt.srcElement.form.elements["data"].value, evt.srcElement.form.getAttribute("dataCurrentEnc"));
          let hmacBytes = toBytes(evt.srcElement.form.elements["hash"].value, currentHashEnc);

          console.log("Key: " + keyBytes);
          console.log("Data: " + dataBytes);
          console.log("HMAC: " + hmacBytes);

          if (keyBytes == null || dataBytes == null) {
            evt.srcElement.form.elements["hash"].value = "";
            setStatus("hmacTab", 0, "<b>error</b>: bad input data");
            return;
          }

          // import raw key
          const hmacKey = await window.crypto.subtle.importKey(
            "raw",
            bytesToUint8Array(keyBytes),
            {
              name: "HMAC",
              hash: {name: alg}
            },
            true,
            ["sign", "verify"]
          ).then(function(key) {
            return key;
          }).catch(function(err) {
            evt.srcElement.form.elements["hash"].value = "";
            setStatus("hmacTab", 0, "<b>error</b>: " + err);
          });

          if (hmacKey == null) {
            return;
          }

          if (evt.srcElement.value == "sign") {
            window.crypto.subtle.sign(
              {
                name: "HMAC",
              },
              hmacKey,
              bytesToUint8Array(dataBytes)
            ).then(function(hmac) {
              value = fromBytes(uint8ArrayToBytes(new Uint8Array(hmac)), currentHashEnc);
              console.log("HMAC: " + hmac);
              console.log("HMAC as " + currentHashEnc + ": " + value);

              evt.srcElement.form.elements["hash"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["hash"].value = "";
              setStatus("hmacTab", 0, "<b>error</b>: " + err);
            });
          } else {
            window.crypto.subtle.verify(
              {
                name: "HMAC",
              },
              hmacKey,
              bytesToUint8Array(hmacBytes),
              bytesToUint8Array(dataBytes)
            ).then(function(isvalid) {
              setStatus("hmacTab", 0, "<b>status</b>: " + isvalid);
            }).catch(function(err) {
              evt.srcElement.form.elements["hash"].value = "";
              setStatus("hmacTab", 0, "<b>error</b>: " + err);
            });
          }
        }

        // initialize fields
        document.getElementById("hmac").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("hmac").setAttribute("data" + "CurrentEnc", "utf-8");
        document.getElementById("hmac").setAttribute("hash" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="ecdsaTab" class="tabcontent">
      <form id="ecdsa">
        <p><b>EC</b>
          <input type="radio" name="curve" id="p-256" value="P-256" checked/> P-256
          <input type="radio" name="curve" id="p-384" value="P-384"/> P-384
          <input type="radio" name="curve" id="p-521" value="P-521"/> P-521
          <br/>
        </p>
        <p><b>Private key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="2"></textarea>
          <br/>
          <b>Public key</b>
          <input type="radio" name="keyPubEnc" value="utf-8" onclick="switchDataEnc(event, 'keyPub');"/> utf-8
          <input type="radio" name="keyPubEnc" value="hex" checked onclick="switchDataEnc(event, 'keyPub');"/> hex
          <input type="radio" name="keyPubEnc" value="base64" onclick="switchDataEnc(event, 'keyPub');" /> base64
          <input type="radio" name="keyPubEnc" value="base64url" onclick="switchDataEnc(event, 'keyPub');"/> base64url
          <br/>
          <textarea id="keyPub" rows="3"></textarea>
          <br/>
          <input type="button" value="clear" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="generate" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="key #1" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="key #2" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="x/y split" onclick="ecdsaPublicSplit(event, 'keyPub');"/>
          <input type="button" value="check" onclick="ecdsaCheckKey(event, 'key', 'keyPub');"/>
          <span class="status"></span>
        </p>
        <p><b>ECDSA</b>
          <input type="radio" name="alg" value="SHA-256" checked/> SHA-256
          <input type="radio" name="alg" value="SHA-384"/> SHA-384
          <input type="radio" name="alg" value="SHA-512"/> SHA-512
          <input type="radio" name="alg" value="SHA-1"/> SHA-1
          <br/>
        </p>
        <p><b>Data</b>
          <input type="radio" name="dataEnc" value="utf-8" checked onclick="switchDataEnc(event, 'data');"/> utf-8
          <input type="radio" name="dataEnc" value="hex" onclick="switchDataEnc(event, 'data');"/> hex
          <input type="radio" name="dataEnc" value="base64" onclick="switchDataEnc(event, 'data');"/> base64
          <input type="radio" name="dataEnc" value="base64url" onclick="switchDataEnc(event, 'data');"/> base64url
          <br/>
          <textarea id="data" rows="10"></textarea>
          <br/>
          <input type="button" value="clear" onclick="ecdsaData(event, 'data');"/>
          <input type="button" value="hello world" onclick="ecdsaData(event, 'data');"/>
        </p>
        <p>
          <input id="sign" type="button" value="sign" onclick="ecdsa(event);"/>
          <input id="verify" type="button" value="verify" onclick="ecdsa(event);"/>
        </p>
        <p>
          <b>Signature</b>
          <input type="radio" name="sgnEnc" value="utf-8" onclick="switchDataEnc(event, 'sgn');"/> utf-8
          <input type="radio" name="sgnEnc" value="hex" checked onclick="switchDataEnc(event, 'sgn');"/> hex
          <input type="radio" name="sgnEnc" value="base64" onclick="switchDataEnc(event, 'sgn');"/> base64
          <input type="radio" name="sgnEnc" value="base64url" onclick="switchDataEnc(event, 'sgn');"/> base64url
          <textarea id="sgn" rows="3"></textarea>
          <br/>
          <input type="button" value="clear" onclick="ecdsaData(event, 'sgn');"/>
          <input type="button" value="r/s split" onclick="hexSplit(event, 'sgn', -2);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        async function ecdsaKey(evt, private, public) {
          let privateBytes = [];
          let publicBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "generate":
              // generate key pair
              const curve = evt.srcElement.form.elements["curve"].value;
              const keyPair = await window.crypto.subtle.generateKey(
                {
                  name: "ECDSA",
                  namedCurve: curve
                },
                true, // is key exportable
                ["sign", "verify"]
              ).then(function(key) {
                return key;
              }).catch(function(err) {
                setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
              });

              // export private key
              privateBytes = await window.crypto.subtle.exportKey(
                "jwk",
                keyPair["privateKey"]
              ).then(function(keydata) {
                return base64UrlToBytes(keydata["d"]);
              }).catch(function(err) {
                setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
              });

              // export public key
              publicBytes = await window.crypto.subtle.exportKey(
                "raw",
                keyPair["publicKey"]
              ).then(function(keydata) {
                return uint8ArrayToBytes(new Uint8Array(keydata));
              }).catch(function(err) {
                setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
              });
              break;
            case "key #1":
              privateBytes = hexToBytes("2768f6b5a126203bcd997554030e394db197403bd5c89fb83854643e34360183");
              publicBytes = hexToBytes("04842016b1a657a6509aaab6cd069cdb79c6338c8139bca9e036037a88057b0375e7eeea10d448ea4c299da6985c3428cdc0fd9eb76bcca8ccaeae600e07339f99");
              evt.srcElement.form.elements["curve"][0].checked = true;
              break;
            case "key #2":
              privateBytes = hexToBytes("1fbd6aa212f0e71c71fe72b569611a0862f58b2714ccd541072426780a1d75b60212e09dbee808db4dfd4994598ee223");
              publicBytes = hexToBytes("04746de76853b4f38ea91fadebdc3c149e987a0e71906603199587c8a8bf3e1f94feff736004ae26966c12324bc95f74c0e59cc2b2019c56762c02cc82a8756472af447789a900ea4fd5b2231725a5b333e7d4377dec95556b5c39dc354314434d");
              evt.srcElement.form.elements["curve"][1].checked = true;
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert params
          const currentPrivateEnc = evt.srcElement.form.getAttribute(private + "CurrentEnc");
          let privateValue = fromBytes(privateBytes, currentPrivateEnc);
          evt.srcElement.form.elements[private].value = privateValue;

          const currentPublicEnc = evt.srcElement.form.getAttribute(public + "CurrentEnc");
          let publicValue = fromBytes(publicBytes, currentPublicEnc);
          evt.srcElement.form.elements[public].value = publicValue;
        }

        function ecdsaData(evt, target) {
          let dataBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "hello world":
              dataBytes = toBytes("hello world", "utf-8");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(dataBytes)), currentDataEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // split public key hex value in textarea
        function ecdsaPublicSplit(evt, target) {
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          if (currentParamEnc != "hex") {
            return;
          }
          let value = evt.srcElement.form.elements[target].value.replace(/(\s|0x)/g, "");
          let regex = new RegExp(".{2}(.{" + (value.length - 2) / 2 + "})", "g");
          evt.srcElement.form.elements[target].value = value[0] + value[1] + "\n" + value.replace(regex, "$1\n");
        }

        async function ecdsaCheckKey(evt, private, public) {
          const curve = evt.srcElement.form.elements["curve"].value;

          let privateBytes = toBytes(evt.srcElement.form.elements[private].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements[public].value, evt.srcElement.form.getAttribute("keyPubCurrentEnc"));

          // create key pair structure
          let keyPair = {
            "crv": curve,
            "d": bytesToBase64Url(privateBytes),
            "ext": true,
            "key_ops": ["sign", "verify"],
            "kty": "EC",
            "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
          };

          let isValid = true;

          // check private key import
          const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDSA",
              namedCurve: curve
            },
            true,
            ["sign"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
          });

          // check public key import
          delete keyPair['d']; // must be removed
          let publicKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDSA",
              namedCurve: curve
            },
            true,
            ["verify"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
          });

          if (isValid) {
            setStatus("ecdsaTab", 0, "<b>status</b>: ok");
          }
        }

        async function ecdsa(evt) {
          const alg = evt.srcElement.form.elements["alg"].value;
          const curve = evt.srcElement.form.elements["curve"].value;
          const currentSgnEnc = evt.srcElement.form.getAttribute("sgnCurrentEnc");

          let privateBytes = toBytes(evt.srcElement.form.elements["key"].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements["keyPub"].value, evt.srcElement.form.getAttribute("keyPubCurrentEnc"));
          let dataBytes = toBytes(evt.srcElement.form.elements["data"].value, evt.srcElement.form.getAttribute("dataCurrentEnc"));

          if (evt.srcElement.value == "sign") {
            if (privateBytes == null || publicBytes == null || dataBytes == null) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: bad input data");
              return;
            }
            // create key pair structure
            const keyPair = {
              "crv": curve,
              "d": bytesToBase64Url(privateBytes),
              "ext": true,
              "key_ops": ["sign"],
              "kty": "EC",
              "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
              "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
            };

            const privateKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPair,
              {
                name: "ECDSA",
                namedCurve: curve
              },
              true,
              ["sign"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });

            window.crypto.subtle.sign(
              {
                name: "ECDSA",
                hash: {name: alg}
              },
              privateKey,
              bytesToUint8Array(dataBytes)
            ).then(function(ecdsa) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(ecdsa)), currentSgnEnc);
              evt.srcElement.form.elements["sgn"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });
          } else {
            if (publicBytes == null || dataBytes == null) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: bad input data");
              return;
            }
            let sgnBytes = toBytes(evt.srcElement.form.elements["sgn"].value, currentSgnEnc);
            // create public key structure
            const keyPub = {
              "crv": curve,
              "ext": true,
              "key_ops": ["verify"],
              "kty": "EC",
              "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
              "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
            };

            const publicKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPub,
              {
                name: "ECDSA",
                namedCurve: curve
              },
              true,
              ["verify"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });

            window.crypto.subtle.verify(
              {
                name: "ECDSA",
                hash: {name: alg}
              },
              publicKey,
              bytesToUint8Array(sgnBytes),
              bytesToUint8Array(dataBytes)
            ).then(function(isvalid) {
              setStatus("ecdsaTab", 1, "<b>status</b>: " + isvalid);
            }).catch(function(err) {
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });
          }
        }

        // initialize fields
        document.getElementById("ecdsa").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("ecdsa").setAttribute("keyPub" + "CurrentEnc", "hex");
        document.getElementById("ecdsa").setAttribute("data" + "CurrentEnc", "utf-8");
        document.getElementById("ecdsa").setAttribute("sgn" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="ecdhTab" class="tabcontent">
      <form id="ecdh">
        <p><b>EC</b>
          <input type="radio" name="curve" id="p-256" value="P-256" checked/> P-256
          <input type="radio" name="curve" id="p-384" value="P-384"/> P-384
          <input type="radio" name="curve" id="p-521" value="P-521"/> P-521
          <span class="status"></span>
        </p>
        <div id="left" style="float: left; width: 49%">
          <p><b>A Private key</b>
            <input type="radio" name="keyAEnc" value="utf-8" onclick="switchDataEnc(event, 'keyA');"/> utf-8
            <input type="radio" name="keyAEnc" value="hex" checked onclick="switchDataEnc(event, 'keyA');"/> hex
            <input type="radio" name="keyAEnc" value="base64" onclick="switchDataEnc(event, 'keyA');" /> base64
            <input type="radio" name="keyAEnc" value="base64url" onclick="switchDataEnc(event, 'keyA');"/> base64url
            <br/>
            <textarea id="keyA" rows="3"></textarea>
            <br/>
            <b>A Public key</b>
            <input type="radio" name="keyPubAEnc" value="utf-8" onclick="switchDataEnc(event, 'keyPubA');"/> utf-8
            <input type="radio" name="keyPubAEnc" value="hex" checked onclick="switchDataEnc(event, 'keyPubA');"/> hex
            <input type="radio" name="keyPubAEnc" value="base64" onclick="switchDataEnc(event, 'keyPubA');" /> base64
            <input type="radio" name="keyPubAEnc" value="base64url" onclick="switchDataEnc(event, 'keyPubA');"/> base64url
            <br/>
            <textarea id="keyPubA" rows="7"></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="generate" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="key #1" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="key #2" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="x/y split" onclick="ecdhPublicSplit(event, 'keyPubA');"/>
            <input type="button" value="check" onclick="ecdhCheckKey(event, 'keyA', 'keyPubA');"/>
          </p>
          <p>
            <input id="derive key" type="button" value="derive key" onclick="ecdh(event, 'keyA', 'keyPubA', 'keyPubB', 'secretA', 0);"/>
            <input id="derive bits" type="button" value="derive bits" onclick="ecdh(event, 'keyA', 'keyPubA', 'keyPubB', 'secretA', 0);"/>
            <input id="derive 512 bits" type="button" value="derive 512 bits" onclick="ecdh(event, 'keyA', 'keyPubA', 'keyPubB', 'secretA', 512);"/>
          </p>
          <p>
            <b>A Secret</b>
            <input type="radio" name="secretAEnc" value="utf-8" onclick="switchDataEnc(event, 'secretA');"/> utf-8
            <input type="radio" name="secretAEnc" value="hex" checked onclick="switchDataEnc(event, 'secretA');"/> hex
            <input type="radio" name="secretAEnc" value="base64" onclick="switchDataEnc(event, 'secretA');"/> base64
            <input type="radio" name="secretAEnc" value="base64url" onclick="switchDataEnc(event, 'secretA');"/> base64url
            <textarea id="secretA" rows="3"></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhData(event, 'secretA');"/>
          </p>
        </div>
        <div id="right" style="float: right; width: 49%">
          <p><b>B Private key</b>
            <input type="radio" name="keyBEnc" value="utf-8" onclick="switchDataEnc(event, 'keyB');"/> utf-8
            <input type="radio" name="keyBEnc" value="hex" checked onclick="switchDataEnc(event, 'keyB');"/> hex
            <input type="radio" name="keyBEnc" value="base64" onclick="switchDataEnc(event, 'keyB');" /> base64
            <input type="radio" name="keyBEnc" value="base64url" onclick="switchDataEnc(event, 'keyB');"/> base64url
            <br/>
            <textarea id="keyB" rows="3"></textarea>
            <br/>
            <b>B Public key</b>
            <input type="radio" name="keyPubBEnc" value="utf-8" onclick="switchDataEnc(event, 'keyPubB');"/> utf-8
            <input type="radio" name="keyPubBEnc" value="hex" checked onclick="switchDataEnc(event, 'keyPubB');"/> hex
            <input type="radio" name="keyPubBEnc" value="base64" onclick="switchDataEnc(event, 'keyPubB');" /> base64
            <input type="radio" name="keyPubBEnc" value="base64url" onclick="switchDataEnc(event, 'keyPubB');"/> base64url
            <br/>
            <textarea id="keyPubB" rows="7"></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="generate" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="key #1" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="key #2" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="x/y split" onclick="ecdhPublicSplit(event, 'keyPubB');"/>
            <input type="button" value="check" onclick="ecdhCheckKey(event, 'keyB', 'keyPubB');"/>
          </p>
          <p>
            <input id="derive key" type="button" value="derive key" onclick="ecdh(event, 'keyB', 'keyPubB', 'keyPubA', 'secretB', 0);"/>
            <input id="derive bits" type="button" value="derive bits" onclick="ecdh(event, 'keyB', 'keyPubB', 'keyPubA', 'secretB', 0);"/>
            <input id="derive 512 bits" type="button" value="derive 512 bits" onclick="ecdh(event, 'keyB', 'keyPubB', 'keyPubA', 'secretB', 512);"/>
          </p>
          <p>
            <b>B Secret</b>
            <input type="radio" name="secretAEnc" value="utf-8" onclick="switchDataEnc(event, 'secretB');"/> utf-8
            <input type="radio" name="secretAEnc" value="hex" checked onclick="switchDataEnc(event, 'secretB');"/> hex
            <input type="radio" name="secretAEnc" value="base64" onclick="switchDataEnc(event, 'secretB');"/> base64
            <input type="radio" name="secretAEnc" value="base64url" onclick="switchDataEnc(event, 'secretB');"/> base64url
            <textarea id="secretB" rows="3"></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhData(event, 'secretB');"/>
          </p>
        </div>
      </form>

      <script>
        async function ecdhKey(evt, private, public) {
          let privateBytes = [];
          let publicBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "generate":
              // generate key pair
              const curve = evt.srcElement.form.elements["curve"].value;
              const keyPair = await window.crypto.subtle.generateKey(
                {
                  name: "ECDH",
                  namedCurve: curve
                },
                true, // is key exportable
                ["deriveKey", "deriveBits"]
              ).then(function(key) {
                return key;
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });

              // export private key
              privateBytes = await window.crypto.subtle.exportKey(
                "jwk",
                keyPair["privateKey"]
              ).then(function(keydata) {
                return base64UrlToBytes(keydata["d"]);
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });

              // export public key
              publicBytes = await window.crypto.subtle.exportKey(
                "raw",
                keyPair["publicKey"]
              ).then(function(keydata) {
                return uint8ArrayToBytes(new Uint8Array(keydata));
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });
              break;
            case "key #1":
              privateBytes = hexToBytes("2768f6b5a126203bcd997554030e394db197403bd5c89fb83854643e34360183");
              publicBytes = hexToBytes("04842016b1a657a6509aaab6cd069cdb79c6338c8139bca9e036037a88057b0375e7eeea10d448ea4c299da6985c3428cdc0fd9eb76bcca8ccaeae600e07339f99");
              evt.srcElement.form.elements["curve"][0].checked = true;
              break;
            case "key #2":
              privateBytes = hexToBytes("1fbd6aa212f0e71c71fe72b569611a0862f58b2714ccd541072426780a1d75b60212e09dbee808db4dfd4994598ee223");
              publicBytes = hexToBytes("04746de76853b4f38ea91fadebdc3c149e987a0e71906603199587c8a8bf3e1f94feff736004ae26966c12324bc95f74c0e59cc2b2019c56762c02cc82a8756472af447789a900ea4fd5b2231725a5b333e7d4377dec95556b5c39dc354314434d");
              evt.srcElement.form.elements["curve"][1].checked = true;
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert params
          const currentPrivateEnc = evt.srcElement.form.getAttribute(private + "CurrentEnc");
          let privateValue = fromBytes(privateBytes, currentPrivateEnc);
          evt.srcElement.form.elements[private].value = privateValue;

          const currentPublicEnc = evt.srcElement.form.getAttribute(public + "CurrentEnc");
          let publicValue = fromBytes(publicBytes, currentPublicEnc);
          evt.srcElement.form.elements[public].value = publicValue;
        }

        function ecdhData(evt, target) {
          let dataBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "hello world":
              dataBytes = toBytes("hello world", "utf-8");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(dataBytes)), currentDataEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // split public key hex value in textarea
        function ecdhPublicSplit(evt, target) {
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          if (currentParamEnc != "hex") {
            return;
          }
          let value = evt.srcElement.form.elements[target].value.replace(/(\s|0x)/g, "");
          let regex = new RegExp(".{2}(.{" + (value.length - 2) / 2 + "})", "g");
          evt.srcElement.form.elements[target].value = value[0] + value[1] + "\n" + value.replace(regex, "$1\n");
        }

        async function ecdhCheckKey(evt, private, public) {
          const curve = evt.srcElement.form.elements["curve"].value;

          let privateBytes = toBytes(evt.srcElement.form.elements[private].value, evt.srcElement.form.getAttribute(private + "CurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements[public].value, evt.srcElement.form.getAttribute(public + "CurrentEnc"));

          // create key pair structure
          let keyPair = {
            "crv": curve,
            "d": bytesToBase64Url(privateBytes),
            "ext": true,
            "key_ops": ["deriveKey", "deriveBits"],
            "kty": "EC",
            "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
          };

          let isValid = true;

          // check private key import
          const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            ["deriveKey", "deriveBits"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          // check public key import
          delete keyPair['d']; // must be removed
          let publicKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            []
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          if (isValid) {
            setStatus("ecdhTab", 0, "<b>status</b>: ok");
          }
        }

        async function ecdh(evt, private, public, public2, secret, bits) {
          const curve = evt.srcElement.form.elements["curve"].value;
          const currentSecretEnc = evt.srcElement.form.getAttribute(secret + "CurrentEnc");

          let privateBytes = toBytes(evt.srcElement.form.elements[private].value, evt.srcElement.form.getAttribute(private + "CurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements[public].value, evt.srcElement.form.getAttribute(public + "CurrentEnc"));
          let public2Bytes = toBytes(evt.srcElement.form.elements[public2].value, evt.srcElement.form.getAttribute(public2 + "CurrentEnc"));

          if (privateBytes == null || publicBytes == null || public2Bytes == null) {
            evt.srcElement.form.elements[secret].value = "";
            setStatus("ecdhTab", 0, "<b>error</b>: bad input data");
            return;
          }

          // create key pair structure
          const keyPair = {
            "crv": curve,
            "d": bytesToBase64Url(privateBytes),
            "ext": true,
            "key_ops": ["deriveKey", "deriveBits"],
            "kty": "EC",
            "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
          };

          const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            ["deriveKey", "deriveBits"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            evt.srcElement.form.elements[secret].value = "";
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          // create public key structure
          const keyPub = {
            "crv": curve,
            "ext": true,
            "key_ops": ["verify"],
            "kty": "EC",
            "x": bytesToBase64Url(public2Bytes.slice(1, (public2Bytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(public2Bytes.slice(public2Bytes.length - (public2Bytes.length - 1) / 2), public2Bytes.length) // y part
          };

          const public2Key = await window.crypto.subtle.importKey(
            "jwk",
            keyPub,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            []
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          if (bits == 0) {
            bits = ((publicBytes.length - 1) / 2) * 8;
          }

          if (evt.srcElement.value.search("bits") != -1) {
            window.crypto.subtle.deriveBits(
              {
                name: "ECDH",
                namedCurve: curve,
                public: public2Key,
              },
              privateKey,
              bits // number of bits to derive, max one coordinate
            ).then(function(bits) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(bits)), currentSecretEnc);
              evt.srcElement.form.elements[secret].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements[secret].value = "";
              setStatus("ecdhTab", 0, "<b>error</b>: " + err);
            });
          } else {
            window.crypto.subtle.deriveKey(
              {
                name: "ECDH",
                namedCurve: curve,
                public: public2Key,
              },
              privateKey,
              {
                name: "AES-CBC",
                length: 128,
              },
              true,
              ["encrypt", "decrypt"]
            ).then(function(keydata) {
              // export private key
              window.crypto.subtle.exportKey(
                "raw",
                keydata
              ).then(function(keydata) {
                let value = fromBytes(uint8ArrayToBytes(new Uint8Array(keydata)), currentSecretEnc);
                evt.srcElement.form.elements[secret].value = value;
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });
            }).catch(function(err) {
              evt.srcElement.form.elements[secret].value = "";
              setStatus("ecdhTab", 0, "<b>error</b>: " + err);
            });
          }
        }

        // initialize fields
        document.getElementById("ecdh").setAttribute("keyA" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("keyPubA" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("keyB" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("keyPubB" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("secretA" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("secretB" + "CurrentEnc", "hex");
      </script>
    </div>

    <script>
      // common functions

      // remove spaces/0x and convert a hex string to a byte array
      function hexToBytes(hex) {
        hex = hex.replace(/(\s|0x)/g, "");
        let reg=/^([0-9a-f]{2})*$/i;
        if (!reg.test(hex)) {
          return null;
        }

        let bytes = [];
        for (bytes = [], c = 0; c < hex.length; c += 2)
          bytes.push(parseInt(hex.substr(c, 2), 16));
        return bytes;
      }

      // convert a byte array to a hex string and decorate it with new lines, spaces and prefixes
      function bytesToHex(bytes, newline = 0, space = 0, prefix = "") {
        let hex = [];
        for (hex = [], i = 0; i < bytes.length; i++) {
          let current = bytes[i] < 0 ? bytes[i] + 256 : bytes[i];
          hex.push((current >>> 4).toString(16));
          hex.push((current & 0xF).toString(16));
        }
        hex = hex.join("");
        if (space == 0 && newline == 0) {
          hex = prefix + hex;
        }
        if (space != 0) {
          let regex = new RegExp("(.{" + space + "})", "g");
          hex = hex.replace(regex, "$1 " + prefix); // add spaces and prefix
          hex = hex.substring(0, hex.length - (1 + prefix.length)); // remove last occurence
          hex = prefix + hex; // add prefix at begining
        }
        if (newline != 0) {
          let regex;
          if (space == 0) {
            regex = new RegExp("(.{" + newline + "})", "g");
            hex = hex.replace(regex, "$1\n" + prefix); // add newline and prefix
            hex = hex.substring(0, hex.length - (1 + prefix.length)); // remove last occurence
            hex = prefix + hex; // add prefix at begining
          } else {
            let fix = newline + (newline / space) * (1 + prefix.length) - 1; // fix newline value
            regex = new RegExp("(.{" + fix + "}) ", "g");
            hex = hex.replace(regex, "$1\n"); // add newlines
          }
        }
        return hex;
      }

      // convert a byte array to base64 url string
      function bytesToBase64Url(bytes) {
        try {
          return btoa(Array.from(new Uint8Array(bytes)).map(val => {
            return String.fromCharCode(val);
          }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        }
        catch(err) {
          return null;
        }
      }

      // convert a base64 url string to byte array
      function base64UrlToBytes(base64url) {
        try {
          return atob(base64url.replace(/-/g, '+').replace(/_/g, '/')).split('').map(val => {
            return val.charCodeAt(0);
          });
        }
        catch(err) {
          return null;
        }
      }

      // convert a byte array to base64 string
      function bytesToBase64(bytes) {
        try {
          return btoa(Array.from(new Uint8Array(bytes)).map(val => {
            return String.fromCharCode(val);
          }).join(''));
        }
        catch(err) {
          return null;
        }
      }

      // convert a base64 string to byte array
      function base64ToBytes(base64) {
        try {
          return atob(base64).split('').map(val => {
            return val.charCodeAt(0);
          });
        }
        catch(err) {
          return null;
        }
      }

      // convert a byte array to Uint8Array
      function bytesToUint8Array(bytes) {
        return new Uint8Array(bytes);
      }

      // convert a Uint8Array byte array to Uint8Array
      function uint8ArrayToBytes(uint8Array) {
        return [].slice.call(uint8Array);
      }

      // convert value to bytes from given encoding
      function toBytes(value, encoding) {
        if (value == null) {
          return [];
        }
        let bytes = [];
        switch (encoding) {
          case "utf-8":
            bytes = uint8ArrayToBytes(new TextEncoder("utf-8").encode(value))
            break;
          case "hex":
            bytes = hexToBytes(value);
            break;
          case "base64":
            bytes = base64ToBytes(value);
            break;
          case "base64url":
            bytes = base64UrlToBytes(value);
            break;
        }
        return bytes;
      }

      // convert bytes to value using given encoding
      function fromBytes(bytes, encoding) {
        if (bytes == null) {
          return "";
        }
        let value;
        switch (encoding) {
          case "utf-8":
            value = new TextDecoder("utf-8").decode(bytesToUint8Array(bytes));
            break;
          case "hex":
            value = bytesToHex(bytes);
            break;
          case "base64":
            value = bytesToBase64(bytes);
            break;
          case "base64url":
            value = bytesToBase64Url(bytes);
            break;
        }
        return value;
      }

      // xor two buffers, input must be larger than key buffer
      function xorBytes(input, key) {
        let output = [];
        for (let i = 0; i < input.length; i++) {
          output.push(input[i] ^ key[i % key.length]);
        }
        return output;
      }

      // convert data in target field, if CurrentEnc isn't set utf-8 as default is used
      function switchDataEnc(evt, target, forceCurrentEnc = null, forceTargetEnc = null) {
        let currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
        if (currentDataEnc == null) {
          currentDataEnc = "utf-8";
        }
        if (forceCurrentEnc != null) {
          currentDataEnc = forceCurrentEnc;
        }

        let targetDataEnc = evt.srcElement.value;
        if (forceTargetEnc != null) {
          targetDataEnc = forceTargetEnc;
        }

        if (currentDataEnc == targetDataEnc) {
          return;
        }

        console.log(currentDataEnc + " -> " + targetDataEnc);

        let value = evt.srcElement.form.elements[target].value;
        console.log("Current value: " + value);
        let bytes = toBytes(value, currentDataEnc);
        console.log("Bytes: " + bytes);
        value = fromBytes(bytes, targetDataEnc);
        console.log("Target value: " + value);
        evt.srcElement.form.elements[target].value = value;

        evt.srcElement.form.setAttribute(target + "CurrentEnc", targetDataEnc);
      }

      // truncate data to given length
      function truncData(evt, target, length) {
        const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");

        let value = evt.srcElement.form.elements[target].value;
        console.log("Current value: " + value);
        let bytes = toBytes(value, currentDataEnc);
        console.log("Bytes: " + bytes);
        bytes = bytes.slice(0, length);
        value = fromBytes(bytes, currentDataEnc);
        console.log("Target value: " + value);
        evt.srcElement.form.elements[target].value = value;
      }

      // split hex value in textarea with block-size blocks
      // negative block value means parts (-2 = two parts)
      function hexSplit(evt, target, block) {
        const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
        if (currentParamEnc != "hex") {
          return;
        }
        let value = evt.srcElement.form.elements[target].value.replace(/(\s|0x)/g, "");
        if (block < 0) {
          block = value.length / 2 / (-block);
        }
        let regex = new RegExp("(.{" + 2*block + "})", "g");
        evt.srcElement.form.elements[target].value = value.replace(regex, "$1\n");
      }

      // show given tab
      function showTab(evt, tabLabel) {
        let i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
          tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
          tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(tabLabel).style.display = "block";
        evt.currentTarget.className += " active";
      }

      function setStatus(tab, statusId, text) {
        document.getElementById(tab).getElementsByClassName("status")[statusId].innerHTML = text;
        window.setTimeout(function() {
          document.getElementById(tab).getElementsByClassName("status")[statusId].innerHTML = "";
        }, 3000);
      }
    </script>

  </body>
</html>
