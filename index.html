<!DOCTYPE html>
<html>
  <head>
    <title>WebCrypto</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=2">
    <style>
      body {
        font-family: sans;
        width: 960px;
        margin: 0 auto;
      }

      textarea {
        font-family: monospace;
        width: 100%;
        padding: 5px;
        box-sizing: border-box;
      }

      input {
        font-size: 100%;
      }

      .tab {
        overflow: hidden;
        background-color: #f1f1f1;
      }

      .tab button {
        background-color: inherit;
        float: left;
        border: none;
        outline: none;
        cursor: pointer;
        padding: 6px 8px;
        transition: 0.3s;
        font-size: 18px;
      }

      .tab button:hover {
        background-color: #ddd;
      }

      .tab button.active {
        background-color: #bbb;
      }

      .tabcontent {
        display: none;
        padding: 6px 12px;
      }
    </style>
  </head>
  <body>
    <div class="tab">
      <button class="tablinks active" onclick="showTab(event, 'defaultTab')">Home</button>
      <button class="tablinks" onclick="showTab(event, 'encodingTab')">Encoding</button>
      <button class="tablinks" onclick="showTab(event, 'otpTab')">OTP</button>
      <button class="tablinks" onclick="showTab(event, 'keyshareTab')">Keyshare</button>
      <button class="tablinks" onclick="showTab(event, 'aesTab')">AES</button>
      <button class="tablinks" onclick="showTab(event, 'shaTab')">SHA</button>
      <button class="tablinks" onclick="showTab(event, 'hmacTab')">HMAC</button>
      <button class="tablinks" onclick="showTab(event, 'rsaTab')">RSA</button>
      <button class="tablinks" onclick="showTab(event, 'ecdsaTab')">ECDSA</button>
      <button class="tablinks" onclick="showTab(event, 'ecdhTab')">ECDH</button>
      <button class="tablinks" onclick="showTab(event, 'pbkdf2Tab')">PBKDF2</button>
    </div>

    <div id="defaultTab" class="tabcontent" style="display: block;">
      <h3>Welcome to WebCrypto!</h3>
      <p>
        This page uses the Web Cryptography API to demonstrate some cryptographic operations.
      </p>
      <p>
        Supplementary resources
        <ul>
          <li><a href="https://www.w3.org/TR/WebCryptoAPI/">Web Cryptography API, W3C Recommendation</a></li>
          <li><a href="https://diafygi.github.io/webcrypto-examples/">Web Cryptography API Live Table</a> with
            <a href="https://github.com/diafygi/webcrypto-examples/">samples</a></li>
          <li>this page <a href="https://github.com/piona/webcrypto">sources</a></li>
        </ul>
      </p>
    </div>

    <div id="encodingTab" class="tabcontent">
      <form id="encoding">
        <p><b>UTF-8</b><br/>
          <textarea id="utf-8" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <p><b>Hexadecimal</b><br/>
          <textarea id="hex" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <p><b>Base64</b><br/>
          <textarea id="base64" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <p><b>Base64URL</b><br/>
          <textarea id="base64url" rows="5" oninput="reencodeData(event);"></textarea>
        </p>
        <input type="button" value="clear all"
                             onclick="
                             document.getElementById('encoding').elements['utf-8'].value = '';
                             document.getElementById('encoding').elements['hex'].value = '';
                             document.getElementById('encoding').elements['base64'].value = '';
                             document.getElementById('encoding').elements['base64url'].value = '';"/>
      </form>

      <script>
        // reencode data to output fields
        function reencodeData(evt) {
          let data = evt.srcElement.value;
          let dataEnc = evt.srcElement.id;

          evt.srcElement.form.elements["utf-8"].value = data;
          evt.srcElement.form.elements["hex"].value = data;
          evt.srcElement.form.elements["base64"].value = data;
          evt.srcElement.form.elements["base64url"].value = data;

          switchDataEnc(evt, "utf-8", dataEnc, "utf-8");
          switchDataEnc(evt, "hex", dataEnc, "hex");
          switchDataEnc(evt, "base64", dataEnc, "base64");
          switchDataEnc(evt, "base64url", dataEnc, "base64url");
        }
      </script>
    </div>

    <div id="otpTab" class="tabcontent">
      <form id="otp">
        <p><b>Input</b>
          <input type="radio" name="plainEnc" value="utf-8" onclick="switchDataEnc(event, 'plain');"/> utf-8
          <input type="radio" name="plainEnc" value="hex" checked onclick="switchDataEnc(event, 'plain');"/> hex
          <input type="radio" name="plainEnc" value="base64" onclick="switchDataEnc(event, 'plain');" /> base64
          <input type="radio" name="plainEnc" value="base64url" onclick="switchDataEnc(event, 'plain');"/> base64url
          <br/>
          <textarea id="plain" rows="5" oninput="otpEncryptAuto(event);"></textarea>
          <br/>
          <input type="button" value="clear"
                               onclick="document.getElementById('otp').elements['plain'].value = '';
                               otpEncryptAuto(event);"/>
          <input type="button" value="hello world"
                               onclick="document.getElementById('otp').elements['plain'].value = 'hello world';
                               switchDataEnc(event, 'plain', 'utf-8', document.getElementById('otp').elements['plainEnc'].value);
                               otpEncryptAuto(event);"/>
        </p>
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="5" oninput="otpEncryptAuto(event);"></textarea>
          <br/>
          <input type="button" value="clear" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="fix length" onclick="otpKey(event);"/>
          <input type="button" value="generate" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="0x00" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="0xff" onclick="otpKey(event); otpEncryptAuto(event);"/>
          <input type="button" value="hello world" onclick="otpKey(event); otpEncryptAuto(event);"/>
        </p>
        <p>
          <input id="crypt" type="button" value="encrypt/decrypt" onclick="otpEncrypt(event);" disabled/>
          <input id="auto" type="checkbox" checked onclick="xorToggleUpdate(event);"/> auto
        </p>
        <p id="output">
          <b>Output</b>
          <input type="radio" name="cipherEnc" value="utf-8" onclick="switchDataEnc(event, 'cipher');"/> utf-8
          <input type="radio" name="cipherEnc" value="hex" checked onclick="switchDataEnc(event, 'cipher');"/> hex
          <input type="radio" name="cipherEnc" value="base64" onclick="switchDataEnc(event, 'cipher');"/> base64
          <input type="radio" name="cipherEnc" value="base64url" onclick="switchDataEnc(event, 'cipher');"/> base64url
          <textarea id="cipher" rows="5" readonly></textarea>
          <input type="button" value="copy as input"
                               onclick="document.getElementById('otp').elements['plain'].value = document.getElementById('otp').elements['cipher'].value;
                               otpEncryptAuto(event);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        // run otp algorithm using xor
        function otpEncrypt(evt) {
          const currentPlainEnc = evt.srcElement.form.getAttribute("plainCurrentEnc");
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");
          const currentCipherEnc = evt.srcElement.form.getAttribute("cipherCurrentEnc");

          let plain = evt.srcElement.form.elements["plain"].value;
          console.log("Plain as " + currentPlainEnc + ": " + plain);

          let plainBytes = toBytes(plain, currentPlainEnc);
          console.log("Plain: " + plainBytes);

          if (plainBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad plain data");
            return;
          }

          let key = evt.srcElement.form.elements["key"].value;
          console.log("Key as " + currentKeyEnc + ": " + key);

          let keyBytes = toBytes(key, currentKeyEnc);
          console.log("Key: " + keyBytes);

          if (keyBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad key data");
            return;
          }

          let cipher = xorBytes(plainBytes, keyBytes);

          console.log("Cipher encoding: " + currentCipherEnc);
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(cipher)), currentCipherEnc);
          console.log("Cipher: " + cipher);
          console.log("Cipher as " + currentCipherEnc + ": " + value);

          evt.srcElement.form.elements["cipher"].value = value;
        }

        // calculate otp if auto update is active
        function otpEncryptAuto(evt) {
          if (!evt.srcElement.form.elements["auto"].checked) {
            return;
          }
          otpEncrypt(evt);
        }

        function otpKey(evt) {
          // some switch cases ended with return
          switch (evt.srcElement.value) {
            case "clear":
              evt.srcElement.form.elements["key"].value = "";
              return;
            case "0x00":
              evt.srcElement.form.elements["key"].value = "00";
              switchDataEnc(evt, "key", "hex", evt.srcElement.form.elements['keyEnc'].value);
              break;
            case "0xff":
              evt.srcElement.form.elements["key"].value = "ff";
              switchDataEnc(evt, "key", "hex", evt.srcElement.form.elements['keyEnc'].value);
              break;
            case "hello world":
              evt.srcElement.form.elements["key"].value = "hello world";
              switchDataEnc(evt, "key", "utf-8", evt.srcElement.form.elements['keyEnc'].value);
              return;
            case "fix length":
            case "generate":
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              return;
          }

          // fix key length
          const currentPlainEnc = evt.srcElement.form.getAttribute("plainCurrentEnc");
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");
          const currentCipherEnc = evt.srcElement.form.getAttribute("cipherCurrentEnc");

          let plain = evt.srcElement.form.elements["plain"].value;
          console.log("Plain as " + currentPlainEnc + ": " + plain);

          let plainBytes = toBytes(plain, currentPlainEnc);
          console.log("Plain: " + plainBytes);

          if (plainBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad plain data");
            return;
          }

          let key = evt.srcElement.form.elements["key"].value;
          console.log("Key as " + currentKeyEnc + ": " + key);

          let keyBytes = toBytes(key, currentKeyEnc);
          console.log("Key: " + keyBytes);

          if (evt.srcElement.value == "generate") {
            keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(plainBytes.length)));
          }

          if (keyBytes == null) {
            evt.srcElement.form.elements["cipher"].value = "";
            setStatus("otpTab", 0, "<b>error</b>: bad key data");
            return;
          }

          let keyBytesFixed = [];
          for (let i = 0; i < plainBytes.length; i++) {
            keyBytesFixed.push(keyBytes[i % keyBytes.length]);
          }

          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(keyBytesFixed)), currentKeyEnc);
          evt.srcElement.form.elements["key"].value = value;
        }

        // enable/disable update button
        function xorToggleUpdate(evt) {
          if (evt.srcElement.form.elements["auto"].checked) {
            evt.srcElement.form.elements["crypt"].disabled = true;
          } else {
            evt.srcElement.form.elements["crypt"].disabled = false;
          }
        }

        // initialize fields
        document.getElementById("otp").setAttribute("plain" + "CurrentEnc", "hex");
        document.getElementById("otp").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("otp").setAttribute("cipher" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="keyshareTab" class="tabcontent">
      <form id="keyshare">
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="3"></textarea>
          <br/>
          <input type="button" value="clear" onclick="keyshareKey(event);"/>
          <input type="button" value="128 bit" onclick="keyshareKey(event);"/>
          <input type="button" value="192 bit" onclick="keyshareKey(event);"/>
          <input type="button" value="256 bit" onclick="keyshareKey(event);"/>
        </p>
        <p>
          <b>Shares: <span id="keyshareShares">3</span></b><br/>
          <input type="range" id="shares" name="shares" min="1" max="16" step="1" value="3" oninput="keyshareUpdateValue(event);"/>
          <textarea id="share" rows="16"></textarea>
          <br/>
          <input type="button" value="clear" onclick="document.getElementById('keyshare').elements['share'].value = '';"/>
          <input type="button" value="split" onclick="keyshareSplit(event);"/>
          <input type="button" value="combine" onclick="keyshareCombine(event);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        // run keyshare split algorithm
        function keyshareSplit(evt) {
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");

          let key = evt.srcElement.form.elements["key"].value;
          console.log("Key as " + currentKeyEnc + ": " + key);

          let keyBytes = toBytes(key, currentKeyEnc);
          console.log("Key: " + keyBytes);

          if (keyBytes == null) {
            evt.srcElement.form.elements["shares"].value = "";
            setStatus("keyshareTab", 0, "<b>error</b>: bad key data");
            return;
          }

          let shares = evt.srcElement.form.elements["shares"].value;
          console.log("Shares: " + shares);

          let xorValue = uint8ArrayToBytes(new Uint8Array(keyBytes.length));

          let value = "";

          // n - 1 random components
          while (shares - 1 > 0) {
            let component = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(keyBytes.length)));
            xorValue = xorBytes(xorValue, component);
            value += fromBytes(component, currentKeyEnc) + "\n";
            shares--;
          }
          // final component
          xorValue = xorBytes(xorValue, keyBytes);
          value += fromBytes(xorValue, currentKeyEnc);

          evt.srcElement.form.elements["share"].value = value;
        }

        // run keyshare combine algorithm
        function keyshareCombine(evt) {
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");

          let components = evt.srcElement.form.elements["share"].value.split("\n");

          // first component
          let xorValue = toBytes(components[0], currentKeyEnc);

          // n - 1 components
          for (let i = 1; i < components.length; i++) {
            let component = toBytes(components[i], currentKeyEnc);
            xorValue = xorBytes(xorValue, component);
          }

          let value = fromBytes(xorValue, currentKeyEnc);

          evt.srcElement.form.elements["key"].value = value;
        }

        function keyshareKey(evt) {
          // some switch cases ended with return
          let keyBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "128 bit":
              keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(16)));
              break;
            case "192 bit":
              keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(24)));
              break;
            case "256 bit":
              keyBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(32)));
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              return;
          }

          // convert key
          const currentKeyEnc = evt.srcElement.form.getAttribute("keyCurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(keyBytes)), currentKeyEnc);
          evt.srcElement.form.elements["key"].value = value;
        }

        // update key shares value from input range
        function keyshareUpdateValue(evt) {
          document.getElementById("keyshareTab").querySelector("#keyshareShares").innerHTML = evt.srcElement.value;
        }

        // initialize fields
        document.getElementById("keyshare").setAttribute("key" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="aesTab" class="tabcontent">
      <form id="aes">
        <p><b>Mode</b>
          <input type="radio" name="mode" value="ECB" checked onclick="aesMode(event);"/> ECB
          <input type="radio" name="mode" value="CBC" onclick="aesMode(event);"/> CBC
          <input type="radio" name="mode" value="CTR" onclick="aesMode(event);"/> CTR
          <input type="radio" name="mode" value="GCM" onclick="aesMode(event);"/> GCM
          <br/>
        </p>
        <span id="aesPadding">
          <p><b>Padding</b>
            <input type="radio" name="padding" value="None" checked/> None
            <input type="radio" name="padding" value="PKCS #7"/> PKCS #7
            <br/>
          </p>
        </span>
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="aesParams(event, 'key');"/>
          <input type="button" value="128 bit" onclick="aesParams(event, 'key');"/>
          <input type="button" value="192 bit" onclick="aesParams(event, 'key');"/>
          <input type="button" value="256 bit" onclick="aesParams(event, 'key');"/>
          <input type="button" value="key #1" onclick="aesParams(event, 'key');"/>
          <input type="button" value="key #2" onclick="aesParams(event, 'key');"/>
        </p>
        <span id="aesParam" hidden>
          <p><b><span id="aesParamName"></span></b>
            <input type="radio" name="paramEnc" value="utf-8" onclick="switchDataEnc(event, 'param');"/> utf-8
            <input type="radio" name="paramEnc" value="hex" checked onclick="switchDataEnc(event, 'param');"/> hex
            <input type="radio" name="paramEnc" value="base64" onclick="switchDataEnc(event, 'param');" /> base64
            <input type="radio" name="paramEnc" value="base64url" onclick="switchDataEnc(event, 'param');"/> base64url
            <br/>
            <textarea id="param" rows="2"></textarea>
            <br/>
            <input type="button" value="clear" onclick="aesParams(event, 'param');"/>
            <input type="button" value="96 bit" onclick="aesParams(event, 'param');"/>
            <input type="button" value="128 bit" onclick="aesParams(event, 'param');"/>
            <input type="button" value="128 zero bit" onclick="aesParams(event, 'param');"/>
            <input type="button" value="param #1" onclick="aesParams(event, 'param');"/>
            <input type="button" value="param #2" onclick="aesParams(event, 'param');"/>
          </p>
        </span>
        <p><b>Input</b>
          <input type="radio" name="inputEnc" value="utf-8" onclick="switchDataEnc(event, 'input');"/> utf-8
          <input type="radio" name="inputEnc" value="hex" checked onclick="switchDataEnc(event, 'input');"/> hex
          <input type="radio" name="inputEnc" value="base64" onclick="switchDataEnc(event, 'input');" /> base64
          <input type="radio" name="inputEnc" value="base64url" onclick="switchDataEnc(event, 'input');"/> base64url
          <br/>
          <textarea id="input" rows="5"></textarea>
          <br/>
          <input type="button" value="clear" onclick="aesParams(event, 'input');"/>
          <input type="button" value="one block" onclick="aesParams(event, 'input');"/>
          <input type="button" value="two blocks" onclick="aesParams(event, 'input');"/>
          <input type="button" value="hex block split" onclick="hexSplit(event, 'input', 16);"/>
        </p>
        <span id="aesAdditionalData" hidden>
          <p><b>Additional data</b>
            <input type="radio" name="aadEnc" value="utf-8" onclick="switchDataEnc(event, 'aad');"/> utf-8
            <input type="radio" name="aadEnc" value="hex" checked onclick="switchDataEnc(event, 'aad');"/> hex
            <input type="radio" name="aadEnc" value="base64" onclick="switchDataEnc(event, 'aad');" /> base64
            <input type="radio" name="aadEnc" value="base64url" onclick="switchDataEnc(event, 'aad');"/> base64url
            <br/>
            <textarea id="aad" rows="5"></textarea>
            <br/>
            <input type="button" value="clear" onclick="document.getElementById('aes').elements['aad'].value = '';"/>
            <input type="button" value="hello world"
                                 onclick="document.getElementById('aes').elements['aad'].value = this.value;
                                 switchDataEnc(event, 'aad', 'utf-8', document.getElementById('aes').elements['aadEnc'].value);"/>
            <input type="button" value="some data"
                                 onclick="document.getElementById('aes').elements['aad'].value = this.value;
                                 switchDataEnc(event, 'aad', 'utf-8', document.getElementById('aes').elements['aadEnc'].value);"/>
          </p>
        </span>
        <p>
          <input id="encrypt" type="button" value="encrypt" onclick="aesCrypt(event);"/>
          <input id="decrypt" type="button" value="decrypt" onclick="aesCrypt(event);"/>
        </p>
        <p>
          <b>Output</b>
          <input type="radio" name="outputEnc" value="utf-8" onclick="switchDataEnc(event, 'output');"/> utf-8
          <input type="radio" name="outputEnc" value="hex" checked onclick="switchDataEnc(event, 'output');"/> hex
          <input type="radio" name="outputEnc" value="base64" onclick="switchDataEnc(event, 'output');"/> base64
          <input type="radio" name="outputEnc" value="base64url" onclick="switchDataEnc(event, 'output');"/> base64url
          <textarea id="output" rows="5" readonly></textarea>
          <br/>
          <input type="button" value="copy as input"
                               onclick="document.getElementById('aes').elements['input'].value = document.getElementById('aes').elements['output'].value;"/>
          <input type="button" value="hex split" onclick="hexSplit(event, 'output', 16);"/>
          <span class="status"></span>
        </p>
        <span id="aesAuthTag" hidden>
          <p><b>Auth tag length</b>
            <input type="radio" name="authTagLength" value="128" checked/> 128
            <input type="radio" name="authTagLength" value="64"/> 64
            <input type="radio" name="authTagLength" value="120"/> 120
            <input type="radio" name="authTagLength" value="112"/> 112
            <input type="radio" name="authTagLength" value="104"/> 104
            <input type="radio" name="authTagLength" value="96"/> 96
            <input type="radio" name="authTagLength" value="32"/> 32
            <br/>
          </p>
          <p><b>Auth tag</b>
            <input type="radio" name="authTagEnc" value="utf-8" onclick="switchDataEnc(event, 'authTag');"/> utf-8
            <input type="radio" name="authTagEnc" value="hex" checked onclick="switchDataEnc(event, 'authTag');"/> hex
            <input type="radio" name="authTagEnc" value="base64" onclick="switchDataEnc(event, 'authTag');"/> base64
            <input type="radio" name="authTagEnc" value="base64url" onclick="switchDataEnc(event, 'authTag');"/> base64url
            <br/>
            <textarea id="authTag" rows="2"></textarea>
            <br/>
            <input type="button" value="clear"
                                 onclick="document.getElementById('aes').elements['authTag'].value = '';"/>
            <input type="button" value="128 bit"
                                 onclick="aesParams(event, 'authTag');"/>
            <input type="button" value="cut"
                                 onclick="truncData(event, 'authTag', document.getElementById('aes').elements['authTagLength'].value / 8);"/>
          </p>
        </span>
      </form>

      <script>
        // show/hide fields when switching mode of operation
        function aesMode(evt) {
          console.log("AES mode: " + evt.srcElement.value);
          let aesTab = document.getElementById("aesTab");
          switch (evt.srcElement.value) {
            case "ECB":
              // padding
              aesTab.querySelector("#aesPadding").removeAttribute("hidden");
              // param
              aesTab.querySelector("#aesParam").setAttribute("hidden", undefined);
              // additional data
              aesTab.querySelector("#aesAdditionalData").setAttribute("hidden", undefined);
              aesTab.querySelector("#aesAuthTag").setAttribute("hidden", undefined);
              break;
            case "CBC":
              // padding
              aesTab.querySelector("#aesPadding").removeAttribute("hidden");
              // param
              aesTab.querySelector("#aesParam").removeAttribute("hidden");
              aesTab.querySelector("#aesParamName").innerHTML = "IV";
              // additional data
              aesTab.querySelector("#aesAdditionalData").setAttribute("hidden", undefined);
              aesTab.querySelector("#aesAuthTag").setAttribute("hidden", undefined);
              break;
            case "CTR":
              // padding
              aesTab.querySelector("#aesPadding").setAttribute("hidden", undefined);
              // param
              aesTab.querySelector("#aesParam").removeAttribute("hidden");
              aesTab.querySelector("#aesParamName").innerHTML = "Counter";
              // additional data and tag
              aesTab.querySelector("#aesAdditionalData").setAttribute("hidden", undefined);
              aesTab.querySelector("#aesAuthTag").setAttribute("hidden", undefined);
              break;
            case "GCM":
              // padding
              aesTab.querySelector("#aesPadding").setAttribute("hidden", undefined);
              // param
              aesTab.querySelector("#aesParam").removeAttribute("hidden");
              aesTab.querySelector("#aesParamName").innerHTML = "Nonce";
              // additional data and tag
              aesTab.querySelector("#aesAdditionalData").removeAttribute("hidden");
              aesTab.querySelector("#aesAuthTag").removeAttribute("hidden");
              break;
            default:
              return;
          }
        }

        function aesParams(evt, target) {
          let paramBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "128 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(16)));
              break;
            case "192 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(24)));
              break;
            case "256 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(32)));
              break;
            case "key #1":
              paramBytes = hexToBytes("6745486a2ee2b58ddb5578b4777e9f13");
              break;
            case "key #2":
              paramBytes = hexToBytes("ead670026e84e4a6c3fd5ebcff381e3cbedf508c80d1342bb9778ec599143f8f");
              break;
            case "96 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(12)));
              break;
            case "param #1":
              paramBytes = hexToBytes("91f916f7b17ecdec0103d690");
              break;
            case "param #2":
              paramBytes = hexToBytes("f10a6dfb41d70df1832eb3df12fb663a");
              break;
            case "128 zero bit":
            case "one block":
              paramBytes = uint8ArrayToBytes(new Uint8Array(16));
              break;
            case "two blocks":
              paramBytes = uint8ArrayToBytes(new Uint8Array(32));
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(paramBytes)), currentParamEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // perform aes encryption/decryption
        async function aesCrypt(evt) {
          evt.srcElement.form.elements["output"].value = "";

          const oper = evt.srcElement.value;
          console.log("Operation: " + oper);

          const mode = evt.srcElement.form.elements["mode"].value;
          console.log("Mode: " + mode);

          const padding = evt.srcElement.form.elements["padding"].value;
          console.log("Padding: " + padding);

          // read and import AES key
          const keyBytes = toBytes(evt.srcElement.form.elements["key"].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));

          // import raw key
          const aesKey = await window.crypto.subtle.importKey(
            "raw",
            bytesToUint8Array(keyBytes),
            "AES-" + (mode == "ECB" ? "CBC" : mode),
            true,
            ["encrypt", "decrypt"]
          ).then(function(key) {
            return key;
          }).catch(function(err) {
            evt.srcElement.form.elements["output"].value = "";
            setStatus("aesTab", 0, "<b>error</b>: " + err);
          });

          if (aesKey == null) {
            return;
          }

          // read input, param and additional data
          let inputBytes = toBytes(evt.srcElement.form.elements["input"].value, evt.srcElement.form.getAttribute("inputCurrentEnc"));
          let paramBytes = toBytes(evt.srcElement.form.elements["param"].value, evt.srcElement.form.getAttribute("paramCurrentEnc"));
          let aadBytes = toBytes(evt.srcElement.form.elements["aad"].value, evt.srcElement.form.getAttribute("aadCurrentEnc"));
          let authTagBytes = toBytes(evt.srcElement.form.elements["authTag"].value, evt.srcElement.form.getAttribute("authTagCurrentEnc"));
          let authTagLength = evt.srcElement.form.elements["authTagLength"].value / 8;

          if ((mode == "ECB" || mode == "CBC") && (padding == "None" || oper == "decrypt")) {
            if (inputBytes == null || inputBytes.length == 0 || inputBytes.length % 16 != 0) {
              evt.srcElement.form.elements["output"].value = "Bad input: must be multiple of 16 bytes";
              return;
            }
          }

          let output = [];
          console.log("inputBytes length = " + inputBytes.length);

          if (mode == "ECB" && oper == "encrypt") { // ECB = use CBC mode for each block
            for (let i = 0; i <= inputBytes.length; i += 16) {
              if (padding == "None" && i == inputBytes.length) {
                break;
              }
              let block = new Uint8Array(inputBytes.slice(i, i + 16));
              const encryptedBlock = await window.crypto.subtle.encrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                block
              ).then(function(encrypted) {
                return encrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              if (encryptedBlock == null) {
                return;
              }
              output = output.concat(uint8ArrayToBytes(new Uint8Array(encryptedBlock, 0, 16)));
            }
          } else if (mode == "ECB" && oper == "decrypt") {
            for (let i = 0; i < inputBytes.length; i += 16) {
              // prepare empty padding
              const emptyPadding = await window.crypto.subtle.encrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                new Uint8Array(xorBytes(uint8ArrayToBytes(new Uint8Array(Array(16).fill(16))), inputBytes.slice(i, i + 16)))
              ).then(function(encrypted) {
                return encrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              console.log(emptyPadding);
              let emptyPaddingBytes = uint8ArrayToBytes(new Uint8Array(emptyPadding, 0, 16));

              let block = [];
              if (i != inputBytes.length - 16) {
                block = new Uint8Array(inputBytes.slice(i, i + 16).concat(emptyPaddingBytes));
              } else {
                if (padding == "None") {
                  block = new Uint8Array(inputBytes.slice(i, i + 16).concat(emptyPaddingBytes));
                } else {
                  block = new Uint8Array(inputBytes.slice(i, i + 16));
                }
              }
              const decryptedBlock = await window.crypto.subtle.decrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                block
              ).then(function(decrypted) {
                return decrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              if (decryptedBlock == null) {
                return;
              }

              if (decryptedBlock.length > 16) {
                output = output.concat(uint8ArrayToBytes(new Uint8Array(decryptedBlock, 0, 16)));
              } else {
                output = output.concat(uint8ArrayToBytes(new Uint8Array(decryptedBlock)));
              }
            }
          } else if (mode == "CBC" && oper == "encrypt") {
            let blocks = new Uint8Array(inputBytes);
            const encryptedBlocks = await window.crypto.subtle.encrypt(
              {
                name: "AES-CBC",
                iv: new Uint8Array(paramBytes),
              },
              aesKey,
              blocks
            ).then(function(encrypted) {
              return encrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (encryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(encryptedBlocks));
            if (padding == "None") {
              output = output.slice(0, output.length - 16);
            }
          } else if (mode == "CBC" && oper == "decrypt") {
            // prepare empty padding
            if (padding == "None") {
              const emptyPadding = await window.crypto.subtle.encrypt(
                {
                  name: "AES-CBC",
                  iv: new Uint8Array(16),
                },
                aesKey,
                new Uint8Array(xorBytes(uint8ArrayToBytes(new Uint8Array(Array(16).fill(16))), inputBytes.slice(inputBytes.length - 16, inputBytes.length)))
              ).then(function(encrypted) {
                return encrypted;
              }).catch(function(err) {
                evt.srcElement.form.elements["output"].value = "";
                setStatus("aesTab", 0, "<b>error</b>: " + err);
              });
              console.log(emptyPadding);
              let emptyPaddingBytes = uint8ArrayToBytes(new Uint8Array(emptyPadding, 0, 16));
              inputBytes = inputBytes.concat(emptyPaddingBytes);
            }
            let blocks = new Uint8Array(inputBytes);
            const decryptedBlocks = await window.crypto.subtle.decrypt(
              {
                name: "AES-CBC",
                iv: new Uint8Array(paramBytes),
              },
              aesKey,
              blocks
            ).then(function(decrypted) {
              return decrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (decryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(decryptedBlocks));
          } else if (mode == "CTR" && oper == "encrypt") {
            let blocks = new Uint8Array(inputBytes);
            const encryptedBlocks = await window.crypto.subtle.encrypt(
              {
                name: "AES-CTR",
                counter: new Uint8Array(paramBytes),
                length: 128
              },
              aesKey,
              blocks
            ).then(function(encrypted) {
              return encrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (encryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(encryptedBlocks));
          } else if (mode == "CTR" && oper == "decrypt") {
            let blocks = new Uint8Array(inputBytes);
            const decryptedBlocks = await window.crypto.subtle.decrypt(
              {
                name: "AES-CTR",
                counter: new Uint8Array(paramBytes),
                length: 128
              },
              aesKey,
              blocks
            ).then(function(decrypted) {
              return decrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (decryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(decryptedBlocks));
          } else if (mode == "GCM" && oper == "encrypt") {
            let blocks = new Uint8Array(inputBytes);
            const encryptedBlocks = await window.crypto.subtle.encrypt(
              {
                name: "AES-GCM",
                iv: new Uint8Array(paramBytes),
                tagLength: authTagLength * 8,
                additionalData: new Uint8Array(aadBytes)
              },
              aesKey,
              blocks
            ).then(function(encrypted) {
              return encrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (encryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(encryptedBlocks));
            authTagBytes = output.slice(output.length - authTagLength, output.length);
            output = output.slice(0, output.length - authTagLength);
          } else if (mode == "GCM" && oper == "decrypt") {
            inputBytes = inputBytes.concat(authTagBytes);
            let blocks = new Uint8Array(inputBytes);
            const decryptedBlocks = await window.crypto.subtle.decrypt(
              {
                name: "AES-GCM",
                iv: new Uint8Array(paramBytes),
                tagLength: authTagLength * 8,
                additionalData: new Uint8Array(aadBytes)
              },
              aesKey,
              blocks
            ).then(function(decrypted) {
              return decrypted;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("aesTab", 0, "<b>error</b>: " + err);
            });
            if (decryptedBlocks == null) {
              return;
            }
            output = uint8ArrayToBytes(new Uint8Array(decryptedBlocks));
          }

          let value = fromBytes(output, evt.srcElement.form.getAttribute("outputCurrentEnc"));
          evt.srcElement.form.elements["output"].value = value;

          if (authTag != null) {
            value = fromBytes(authTagBytes, evt.srcElement.form.getAttribute("authTagCurrentEnc"));
            evt.srcElement.form.elements["authTag"].value = value;
          }
        }

        // initialize fields
        document.getElementById("aes").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("param" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("input" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("aad" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("output" + "CurrentEnc", "hex");
        document.getElementById("aes").setAttribute("authTag" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="shaTab" class="tabcontent">
      <form id="sha">
        <p><b>SHA</b>
          <input type="radio" name="alg" value="SHA-256" checked onclick="shaHashAuto(event);"/> SHA-256
          <input type="radio" name="alg" value="SHA-384" onclick="shaHashAuto(event);"/> SHA-384
          <input type="radio" name="alg" value="SHA-512" onclick="shaHashAuto(event);"/> SHA-512
          <input type="radio" name="alg" value="SHA-1" onclick="shaHashAuto(event);"/> SHA-1
          <br/>
        </p>
        <p><b>Data</b>
          <input type="radio" name="dataEnc" value="utf-8" checked onclick="switchDataEnc(event, 'data');"/> utf-8
          <input type="radio" name="dataEnc" value="hex" onclick="switchDataEnc(event, 'data');"/> hex
          <input type="radio" name="dataEnc" value="base64" onclick="switchDataEnc(event, 'data');"/> base64
          <input type="radio" name="dataEnc" value="base64url" onclick="switchDataEnc(event, 'data');"/> base64url
          <br/>
          <textarea id="data" rows="10" oninput="shaHashAuto(event);"></textarea>
          <br/>
          <input type="button" value="clear"
                               onclick="document.getElementById('sha').elements['data'].value = '';
                               shaHashAuto(event);"/>
          <input type="button" value="hello world"
                               onclick="document.getElementById('sha').elements['data'].value = 'hello world';
                               switchDataEnc(event, 'data', 'utf-8', document.getElementById('sha').elements['dataEnc'].value);
                               shaHashAuto(event);"/>
        </p>
        <p>
          <input id="update" type="button" value="update" onclick="shaHash(event);" disabled/>
          <input id="auto" type="checkbox" checked onclick="shaToggleUpdate(event);"/> auto
        </p>
        <p>
          <b>Hash</b>
          <input type="radio" name="hashEnc" value="utf-8" onclick="switchDataEnc(event, 'hash');"/> utf-8
          <input type="radio" name="hashEnc" value="hex" checked onclick="switchDataEnc(event, 'hash');"/> hex
          <input type="radio" name="hashEnc" value="base64" onclick="switchDataEnc(event, 'hash');"/> base64
          <input type="radio" name="hashEnc" value="base64url" onclick="switchDataEnc(event, 'hash');"/> base64url
          <textarea id="hash" rows="2" readonly></textarea>
          <br/>
          <input type="button" value="copy as data"
                               onclick="document.getElementById('sha').elements['data'].value = document.getElementById('sha').elements['hash'].value;
                               shaHashAuto(event);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        // calculate hash value
        function shaHash(evt) {
          const currentDataEnc = evt.srcElement.form.getAttribute("dataCurrentEnc");
          const currentHashEnc = evt.srcElement.form.getAttribute("hashCurrentEnc");
          const alg = evt.srcElement.form.elements["alg"].value;
          console.log("Algorithm: " + alg);

          let value = evt.srcElement.form.elements["data"].value;
          console.log("Data as " + currentDataEnc + ": " + value);

          let bytes = toBytes(value, currentDataEnc);
          console.log("Data: " + bytes);

          if (bytes == null) {
            evt.srcElement.form.elements["hash"].value = "";
            setStatus("shaTab", 0, "<b>error</b>: bad input data");
            return;
          }

          window.crypto.subtle.digest(
            {
              name: alg
            },
            bytesToUint8Array(bytes)
          ).then(function(hash) {
            console.log("Hash encoding: " + currentHashEnc);
            let value = fromBytes(uint8ArrayToBytes(new Uint8Array(hash)), currentHashEnc);
            console.log("Hash: " + hash);
            console.log("Hash as " + currentHashEnc + ": " + value);

            evt.srcElement.form.elements["hash"].value = value;
          }).catch(function(err) {
            console.error(err);
          });
        }

        // calculate hash if auto update is active
        function shaHashAuto(evt) {
          if (!evt.srcElement.form.elements["auto"].checked) {
            return;
          }
          shaHash(evt);
        }

        // enable/disable update button
        function shaToggleUpdate(evt) {
          if (evt.srcElement.form.elements["auto"].checked) {
            evt.srcElement.form.elements["update"].disabled = true;
          } else {
            evt.srcElement.form.elements["update"].disabled = false;
          }
        }

        // initialize fields
        document.getElementById("sha").setAttribute("data" + "CurrentEnc", "utf-8");
        document.getElementById("sha").setAttribute("hash" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="hmacTab" class="tabcontent">
      <form id="hmac">
        <p><b>HMAC</b>
          <input type="radio" name="alg" value="SHA-256" checked/> SHA-256
          <input type="radio" name="alg" value="SHA-384"/> SHA-384
          <input type="radio" name="alg" value="SHA-512"/> SHA-512
          <input type="radio" name="alg" value="SHA-1"/> SHA-1
          <br/>
        </p>
        <p><b>Key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="128 bit" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="192 bit" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="256 bit" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="key #1" onclick="hmacParams(event, 'key');"/>
          <input type="button" value="key #2" onclick="hmacParams(event, 'key');"/>
        </p>
        <p><b>Data</b>
          <input type="radio" name="dataEnc" value="utf-8" checked onclick="switchDataEnc(event, 'data');"/> utf-8
          <input type="radio" name="dataEnc" value="hex" onclick="switchDataEnc(event, 'data');"/> hex
          <input type="radio" name="dataEnc" value="base64" onclick="switchDataEnc(event, 'data');"/> base64
          <input type="radio" name="dataEnc" value="base64url" onclick="switchDataEnc(event, 'data');"/> base64url
          <br/>
          <textarea id="data" rows="10"></textarea>
          <br/>
          <input type="button" value="clear" onclick="hmacParams(event, 'data');"/>
          <input type="button" value="hello world" onclick="hmacParams(event, 'data');"/>
        </p>
        <p>
          <input id="sign" type="button" value="sign" onclick="hmac(event);"/>
          <input id="verify" type="button" value="verify" onclick="hmac(event);"/>
        </p>
        <p>
          <b>HMAC</b>
          <input type="radio" name="hashEnc" value="utf-8" onclick="switchDataEnc(event, 'hash');"/> utf-8
          <input type="radio" name="hashEnc" value="hex" checked onclick="switchDataEnc(event, 'hash');"/> hex
          <input type="radio" name="hashEnc" value="base64" onclick="switchDataEnc(event, 'hash');"/> base64
          <input type="radio" name="hashEnc" value="base64url" onclick="switchDataEnc(event, 'hash');"/> base64url
          <textarea id="hash" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="160 bit" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="256 bit" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="384 bit" onclick="hmacParams(event, 'hash');"/>
          <input type="button" value="512 bit" onclick="hmacParams(event, 'hash');"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        function hmacParams(evt, target) {
          let paramBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "128 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(16)));
              break;
            case "160 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(20)));
              break;
            case "192 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(24)));
              break;
            case "256 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(32)));
              break;
            case "384 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(48)));
              break;
            case "512 bit":
              paramBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(64)));
              break;
            case "key #1":
              paramBytes = hexToBytes("250a9def94c78a02c141b37387a6190f");
              break;
            case "key #2":
              paramBytes = hexToBytes("f9c15df9095732493c18e959f2933d7a37391bae2c7dd85e1f0e0ca45a5913cd");
              break;
            case "hello world":
              paramBytes = toBytes("hello world", "utf-8");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(paramBytes)), currentParamEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // calculate hash value
        async function hmac(evt) {
          const alg = evt.srcElement.form.elements["alg"].value;
          console.log("Algorithm: " + alg);

          const currentHashEnc = evt.srcElement.form.getAttribute("hashCurrentEnc");

          let keyBytes = toBytes(evt.srcElement.form.elements["key"].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));
          let dataBytes = toBytes(evt.srcElement.form.elements["data"].value, evt.srcElement.form.getAttribute("dataCurrentEnc"));
          let hmacBytes = toBytes(evt.srcElement.form.elements["hash"].value, currentHashEnc);

          console.log("Key: " + keyBytes);
          console.log("Data: " + dataBytes);
          console.log("HMAC: " + hmacBytes);

          if (keyBytes == null || dataBytes == null) {
            evt.srcElement.form.elements["hash"].value = "";
            setStatus("hmacTab", 0, "<b>error</b>: bad input data");
            return;
          }

          // import raw key
          const hmacKey = await window.crypto.subtle.importKey(
            "raw",
            bytesToUint8Array(keyBytes),
            {
              name: "HMAC",
              hash: {name: alg}
            },
            true,
            ["sign", "verify"]
          ).then(function(key) {
            return key;
          }).catch(function(err) {
            evt.srcElement.form.elements["hash"].value = "";
            setStatus("hmacTab", 0, "<b>error</b>: " + err);
          });

          if (hmacKey == null) {
            return;
          }

          if (evt.srcElement.value == "sign") {
            window.crypto.subtle.sign(
              {
                name: "HMAC",
              },
              hmacKey,
              bytesToUint8Array(dataBytes)
            ).then(function(hmac) {
              value = fromBytes(uint8ArrayToBytes(new Uint8Array(hmac)), currentHashEnc);
              console.log("HMAC: " + hmac);
              console.log("HMAC as " + currentHashEnc + ": " + value);

              evt.srcElement.form.elements["hash"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["hash"].value = "";
              setStatus("hmacTab", 0, "<b>error</b>: " + err);
            });
          } else {
            window.crypto.subtle.verify(
              {
                name: "HMAC",
              },
              hmacKey,
              bytesToUint8Array(hmacBytes),
              bytesToUint8Array(dataBytes)
            ).then(function(isvalid) {
              setStatus("hmacTab", 0, "<b>status</b>: " + isvalid);
            }).catch(function(err) {
              evt.srcElement.form.elements["hash"].value = "";
              setStatus("hmacTab", 0, "<b>error</b>: " + err);
            });
          }
        }

        // initialize fields
        document.getElementById("hmac").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("hmac").setAttribute("data" + "CurrentEnc", "utf-8");
        document.getElementById("hmac").setAttribute("hash" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="rsaTab" class="tabcontent">
      <form id="rsa">
        <p><b>RSA</b>
          <input type="radio" name="mode" value="OAEP" checked onclick="rsaMode(event);"/> OAEP
          <input type="radio" name="mode" value="PSS" onclick="rsaMode(event);"/> PSS
          <br/>
        </p>
        <p><b>Key length</b>
          <input type="radio" name="keyLength" value="1024" checked/> 1024
          <input type="radio" name="keyLength" value="2048"/> 2048
          <input type="radio" name="keyLength" value="4096"/> 4096
          <br/>
        </p>
        <p><b>Key modulus (n)</b>
          <input type="radio" name="key_nEnc" value="utf-8" onclick="switchDataEnc(event, 'key_n');"/> utf-8
          <input type="radio" name="key_nEnc" value="hex" checked onclick="switchDataEnc(event, 'key_n');"/> hex
          <input type="radio" name="key_nEnc" value="base64" onclick="switchDataEnc(event, 'key_n');" /> base64
          <input type="radio" name="key_nEnc" value="base64url" onclick="switchDataEnc(event, 'key_n');"/> base64url
          <br/>
          <textarea id="key_n" rows="5"></textarea>
          <br/>
          <b>Public exponent (e)</b>
          <input type="radio" name="key_eEnc" value="utf-8" onclick="switchDataEnc(event, 'key_e');"/> utf-8
          <input type="radio" name="key_eEnc" value="hex" checked onclick="switchDataEnc(event, 'key_e');"/> hex
          <input type="radio" name="key_eEnc" value="base64" onclick="switchDataEnc(event, 'key_e');" /> base64
          <input type="radio" name="key_eEnc" value="base64url" onclick="switchDataEnc(event, 'key_e');"/> base64url
          <br/>
          <textarea id="key_e" rows="1"></textarea>
          <br/>
          <b>Private exponent (d)</b>
          <input type="radio" name="key_dEnc" value="utf-8" onclick="switchDataEnc(event, 'key_d');"/> utf-8
          <input type="radio" name="key_dEnc" value="hex" checked onclick="switchDataEnc(event, 'key_d');"/> hex
          <input type="radio" name="key_dEnc" value="base64" onclick="switchDataEnc(event, 'key_d');" /> base64
          <input type="radio" name="key_dEnc" value="base64url" onclick="switchDataEnc(event, 'key_d');"/> base64url
          <br/>
          <textarea id="key_d" rows="5"></textarea>
          <br/>
          <b>Private prime p (p)</b>
          <input type="radio" name="key_pEnc" value="utf-8" onclick="switchDataEnc(event, 'key_p');"/> utf-8
          <input type="radio" name="key_pEnc" value="hex" checked onclick="switchDataEnc(event, 'key_p');"/> hex
          <input type="radio" name="key_pEnc" value="base64" onclick="switchDataEnc(event, 'key_p');" /> base64
          <input type="radio" name="key_pEnc" value="base64url" onclick="switchDataEnc(event, 'key_p');"/> base64url
          <br/>
          <textarea id="key_p" rows="3"></textarea>
          <br/>
          <b>Private prime q (q)</b>
          <input type="radio" name="key_qEnc" value="utf-8" onclick="switchDataEnc(event, 'key_q');"/> utf-8
          <input type="radio" name="key_qEnc" value="hex" checked onclick="switchDataEnc(event, 'key_q');"/> hex
          <input type="radio" name="key_qEnc" value="base64" onclick="switchDataEnc(event, 'key_q');" /> base64
          <input type="radio" name="key_qEnc" value="base64url" onclick="switchDataEnc(event, 'key_q');"/> base64url
          <br/>
          <textarea id="key_q" rows="3"></textarea>
          <br/>
          <b>Private exponent p (dp)</b>
          <input type="radio" name="key_dpEnc" value="utf-8" onclick="switchDataEnc(event, 'key_dp');"/> utf-8
          <input type="radio" name="key_dpEnc" value="hex" checked onclick="switchDataEnc(event, 'key_dp');"/> hex
          <input type="radio" name="key_dpEnc" value="base64" onclick="switchDataEnc(event, 'key_dp');" /> base64
          <input type="radio" name="key_dpEnc" value="base64url" onclick="switchDataEnc(event, 'key_dp');"/> base64url
          <br/>
          <textarea id="key_dp" rows="3"></textarea>
          <br/>
          <b>Private exponent q (dq)</b>
          <input type="radio" name="key_dqEnc" value="utf-8" onclick="switchDataEnc(event, 'key_dq');"/> utf-8
          <input type="radio" name="key_dqEnc" value="hex" checked onclick="switchDataEnc(event, 'key_dq');"/> hex
          <input type="radio" name="key_dqEnc" value="base64" onclick="switchDataEnc(event, 'key_dq');" /> base64
          <input type="radio" name="key_dqEnc" value="base64url" onclick="switchDataEnc(event, 'key_dq');"/> base64url
          <br/>
          <textarea id="key_dq" rows="3"></textarea>
          <br/>
          <b>Private coefficient (qi)</b>
          <input type="radio" name="key_qiEnc" value="utf-8" onclick="switchDataEnc(event, 'key_qi');"/> utf-8
          <input type="radio" name="key_qiEnc" value="hex" checked onclick="switchDataEnc(event, 'key_qi');"/> hex
          <input type="radio" name="key_qiEnc" value="base64" onclick="switchDataEnc(event, 'key_qi');" /> base64
          <input type="radio" name="key_qiEnc" value="base64url" onclick="switchDataEnc(event, 'key_qi');"/> base64url
          <br/>
          <textarea id="key_qi" rows="3"></textarea>
          <br/>
          <input type="button" value="clear" onclick="rsaKey(event, 'key_n', 'key_e', 'key_d', 'key_p', 'key_q', 'key_dp', 'key_dq', 'key_qi');"/>
          <input type="button" value="clear private" onclick="rsaKey(event, 'key_n', 'key_e', 'key_d', 'key_p', 'key_q', 'key_dp', 'key_dq', 'key_qi');"/>
          <input type="button" value="generate" onclick="rsaKey(event, 'key_n', 'key_e', 'key_d', 'key_p', 'key_q', 'key_dp', 'key_dq', 'key_qi');"/>
          <input type="button" value="key #1" onclick="rsaKey(event, 'key_n', 'key_e', 'key_d', 'key_p', 'key_q', 'key_dp', 'key_dq', 'key_qi');"/>
          <input type="button" value="key #2" onclick="rsaKey(event, 'key_n', 'key_e', 'key_d', 'key_p', 'key_q', 'key_dp', 'key_dq', 'key_qi');"/>
          <input type="button" value="check" onclick="rsaCheckKey(event, 'key_n', 'key_e', 'key_d', 'key_p', 'key_q', 'key_dp', 'key_dq', 'key_qi');"/>
          <span class="status"></span>
        </p>
        <p><b>Hash</b>
          <input type="radio" name="alg" value="SHA-256" checked/> SHA-256
          <input type="radio" name="alg" value="SHA-384"/> SHA-384
          <input type="radio" name="alg" value="SHA-512"/> SHA-512
          <input type="radio" name="alg" value="SHA-1"/> SHA-1
          <br/>
        </p>
        <span id="rsaSignature" hidden>
        <p><b>Data</b>
          <input type="radio" name="dataEnc" value="utf-8" checked onclick="switchDataEnc(event, 'data');"/> utf-8
          <input type="radio" name="dataEnc" value="hex" onclick="switchDataEnc(event, 'data');"/> hex
          <input type="radio" name="dataEnc" value="base64" onclick="switchDataEnc(event, 'data');"/> base64
          <input type="radio" name="dataEnc" value="base64url" onclick="switchDataEnc(event, 'data');"/> base64url
          <br/>
          <textarea id="data" rows="10"></textarea>
          <br/>
          <input type="button" value="clear" onclick="rsaData(event, 'data');"/>
          <input type="button" value="hello world" onclick="rsaData(event, 'data');"/>
        </p>
        <p>
          <input id="sign" type="button" value="sign" onclick="rsa(event);"/>
          <input id="verify" type="button" value="verify" onclick="rsa(event);"/>
        </p>
        <p>
          <b>Signature</b>
          <input type="radio" name="sgnEnc" value="utf-8" onclick="switchDataEnc(event, 'sgn');"/> utf-8
          <input type="radio" name="sgnEnc" value="hex" checked onclick="switchDataEnc(event, 'sgn');"/> hex
          <input type="radio" name="sgnEnc" value="base64" onclick="switchDataEnc(event, 'sgn');"/> base64
          <input type="radio" name="sgnEnc" value="base64url" onclick="switchDataEnc(event, 'sgn');"/> base64url
          <textarea id="sgn" rows="5"></textarea>
          <br/>
          <input type="button" value="clear" onclick="rsaData(event, 'sgn');"/>
          <span class="status"></span>
          </p>
        </span>
        <span id="rsaEncryption">
        <p><b>Input</b>
          <input type="radio" name="inputEnc" value="utf-8" onclick="switchDataEnc(event, 'input');"/> utf-8
          <input type="radio" name="inputEnc" value="hex" checked onclick="switchDataEnc(event, 'input');"/> hex
          <input type="radio" name="inputEnc" value="base64" onclick="switchDataEnc(event, 'input');"/> base64
          <input type="radio" name="inputEnc" value="base64url" onclick="switchDataEnc(event, 'input');"/> base64url
          <br/>
          <textarea id="input" rows="5"></textarea>
          <br/>
          <input type="button" value="clear" onclick="rsaData(event, 'input');"/>
          <input type="button" value="hello world" onclick="rsaData(event, 'input');"/>
        </p>
        <p>
          <input id="encrypt" type="button" value="encrypt" onclick="rsa(event);"/>
          <input id="decrypt" type="button" value="decrypt" onclick="rsa(event);"/>
        </p>
        <p>
          <b>Output</b>
          <input type="radio" name="outputEnc" value="utf-8" onclick="switchDataEnc(event, 'output');"/> utf-8
          <input type="radio" name="outputEnc" value="hex" checked onclick="switchDataEnc(event, 'output');"/> hex
          <input type="radio" name="outputEnc" value="base64" onclick="switchDataEnc(event, 'output');"/> base64
          <input type="radio" name="outputEnc" value="base64url" onclick="switchDataEnc(event, 'output');"/> base64url
          <textarea id="output" rows="5"></textarea>
          <br/>
          <input type="button" value="clear" onclick="rsaData(event, 'output');"/>
          <input type="button" value="copy as input"
                               onclick="document.getElementById('rsa').elements['input'].value = document.getElementById('rsa').elements['output'].value;"/>
          <span class="status"></span>
          </p>
        </p>
        </span>
      </form>

      <script>
        // show/hide fields when switching mode of operation
        function rsaMode(evt) {
          console.log("RSA mode: " + evt.srcElement.value);
          let rsaTab = document.getElementById("rsaTab");
          switch (evt.srcElement.value) {
            case "OAEP":
              // encryption
              rsaTab.querySelector("#rsaEncryption").removeAttribute("hidden");
              rsaTab.querySelector("#rsaSignature").setAttribute("hidden", undefined);
              break;
            case "PSS":
              // signature
              rsaTab.querySelector("#rsaSignature").removeAttribute("hidden");
              rsaTab.querySelector("#rsaEncryption").setAttribute("hidden", undefined);
              break;
            default:
              return;
          }
        }

        async function rsaKey(evt, key_n, key_e, key_d, key_p, key_q, key_dp, key_dq, key_qi) {
          let key_eBytes = [];
          let key_nBytes = [];
          let key_dBytes = [];
          let key_pBytes = [];
          let key_qBytes = [];
          let key_dpBytes = [];
          let key_dqBytes = [];
          let key_qiBytes = [];

          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "clear private":
              key_nBytes = toBytes(evt.srcElement.form.elements[key_n].value, evt.srcElement.form.getAttribute("key_nCurrentEnc"));
              key_eBytes = toBytes(evt.srcElement.form.elements[key_e].value, evt.srcElement.form.getAttribute("key_eCurrentEnc"));
              break;
            case "generate":
              // generate key pair
              const length = evt.srcElement.form.elements["keyLength"].value;
              const alg = evt.srcElement.form.elements["alg"].value;
              const keyPair = await window.crypto.subtle.generateKey(
                {
                  name: "RSA-PSS",
                  modulusLength: length,
                  publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                  hash: {name: alg}
                },
                true, // is key exportable
                ["sign", "verify"]
              ).then(function(key) {
                return key;
              }).catch(function(err) {
                setStatus("rsaTab", 0, "<b>error</b>: " + err);
              });

              // export private key
              privateKey = await window.crypto.subtle.exportKey(
                "jwk",
                keyPair["privateKey"]
              ).then(function(keydata) {
                return keydata;
              }).catch(function(err) {
                setStatus("rsaTab", 0, "<b>error</b>: " + err);
              });

              // export public key
              publicKey = await window.crypto.subtle.exportKey(
                "jwk",
                keyPair["publicKey"]
              ).then(function(keydata) {
                return keydata;
              }).catch(function(err) {
                setStatus("rsaTab", 0, "<b>error</b>: " + err);
              });

              key_nBytes = base64UrlToBytes(publicKey["n"]);
              key_eBytes = base64UrlToBytes(publicKey["e"]);
              key_dBytes = base64UrlToBytes(privateKey["d"]);
              key_pBytes = base64UrlToBytes(privateKey["p"]);
              key_qBytes = base64UrlToBytes(privateKey["q"]);
              key_dpBytes = base64UrlToBytes(privateKey["dp"]);
              key_dqBytes = base64UrlToBytes(privateKey["dq"]);
              key_qiBytes = base64UrlToBytes(privateKey["qi"]);
              break;
            case "key #1":
              key_nBytes = hexToBytes("b3b9ce6c37a108745348f76dfdecc3a7265615e9edca2ba9e1d804858bbb418ae266346e79fda5d2039bd57b00c505c661bcfbeffdb289b31391d94d32ff014dc775d22df0e854047854c1be0db4cee1748703c404fbac20d04cbf9fe87f0ab5613f5c4e030052854a8f2486a5216f94edad808f2d3a81d92c553932cff827bb");
              key_eBytes = hexToBytes("010001");
              key_dBytes = hexToBytes("46c4ed61736e377406af7eae93043dee7d8bfc4906d74ae63405e991e479b1cf4c62ce568a36b4aac3bd030cd23ac291613f173d62fa807a414476fa8d1018a4abec88be9b71f8af089b4eaf39f8571eccf2421d1cf4d880b53313b648e04bac5d28ee0dd9be6719928f767a5314e8518901687eccd36e27623c2cb23c959991");
              key_pBytes = hexToBytes("ef429ed85a7c3bc064dfb4ad5a6cfa9a40f6ef52af91c0c4e62c9d76963ac8c97c751902048c48ff2131c9bda69a375275259848c3910d5689e7e51824442d3f");
              key_qBytes = hexToBytes("c04cde07839173f02d9f8e5c0712173a5d327b7fecef54cb8a0f89b1d6423a747765bd58d0157840d7c044af627dd2469fc91b8f6e947e764a38a4a6e3bbda85");
              key_dpBytes = hexToBytes("e0ec763bda44b43f58155ddb22091545f210b247bf397c491e418efe2e98b0ad89cce3679c32ed64bb25fd0bc7156f309b646e56e952f1810b3fef84d4832b2d");
              key_dqBytes = hexToBytes("1b7da1ac1f51f6ea1a0b9a556ba9596abd920ef7bdce8527c7e7eabe62abfb215544552a522d0f90ed870e0aa8a0e623b48a128791be66c9d05882a95d1b28e5");
              key_qiBytes = hexToBytes("e97b6a4f203fcc39950513385f9369b44f92c95ccb75068045cdf7a1252af1dc693c5d27eeefcc4963587964ae2ad9d24deb0b0ae4f8ae9b12c05200c1ebaf6f");
              evt.srcElement.form.elements["keyLength"][0].checked = true;
              break;
            case "key #2":
              key_nBytes = hexToBytes("d4e12f5c08c1425465c3230245e1a7f890e8302e7daee9c322fa6367e42dbec83bc9edb88de366779b20347afe2cb9ebd0b363d704e862642899f5eaab50d0d1b1cab6cb65cb60607a1f8a65bf98314ecae816526f63f3f279607a4d63d2a15460675b8584a4b1d3bcbc28fe837c6cb2cb9f6716107c53ae8b6b9568584fca775cfe528af454b4de990cb8e62387962324c3dea8b89dca40cc768f5d5c0b9191c86d9a59e33f965adf1cc41fa807bd0ad1b83504d41d2bde79ae0fcd4040a9a200f2a566644716d38566be0b319af703f67615178a04e7d5ea59335b169e775dd09dfb849e3205a0ec1be6aa3f1fd480be0387f1ca279ff42f45d9667ce68181");
              key_eBytes = hexToBytes("010001");
              key_dBytes = hexToBytes("f6a42a200e5f88a1653d85e8fd4c20c26b954e3d9775509fa2bfce57cc327620b58807b9c9e4c4d590efd1cd9df606a4a2d87f6b370472a84a6a8aa8c2a6e1bd7e048f6e784240e586a952e3a4d415659e293361091522570887de33d869bff9217ee0e7c2c4d4a6a4ddd835e0783a04a33d8a4d2933c9fa72dcb927955ba330876962fd92d1c9f4884702eec1fa8926bdbb4ea2436f454b06ebd53c65db6d6695b9749b3db003956740d37c06911a642ef2e440033c9e6a11f79246ed0ba943d811c6370fcbd2cc31ffce109cd565c6646c3550fa6189aec5e60d8b061a2bc54b6a778703c7da00e053a2879314e95cfe09d323e7133ef24bb9d9a989a7fd");
              key_pBytes = hexToBytes("ec586f22d24b4561ec4cac7b45ebb309fbe38c99dae03d825b0e05ac77433ee78e1db262988d04de2def418b39b7c4a7438ee04e8ed7e4a979468ab24328d03f52eed860f912518e54228930679ac897b98caeadb61754dc3a63b6881f92a8176f4797b53c01eba02f5d8cf13671fa9f996d70bfc9fefea188736f0c3aeac62d");
              key_qBytes = hexToBytes("e6952fb39e7aff131965cbb65ed6632818359b87e20f38fe5c9ecdebdbd04a572304c9d73e3fc02c796252bae5b23ee82f12aa5b36684b57e7ca3e6451d9dfd03bc14bafb050699345e4450f1b0d840c2efcb818e95079db095688ec4a696f26196d7b59c7ebcb9761a8b35f692ab86d170ae4759093b8af399bef54f2367125");
              key_dpBytes = hexToBytes("2e80cc053ef97e8260fb4928cc3e2f3134b5b63183a68193c794bfbb0a9059ad380251da228804c02eab97eaec05639541aeb825dce74fdfa4b4239025b4bf1ce695864fb6524b67c4d832c42a6e832f8f5bc5f6fa10272b59f5cab187fcd444202a27088af119ca9fe7395730ce4670e6c068e1e3bddf9e2afa038c957f2255");
              key_dqBytes = hexToBytes("b1ef1bf162f18d16a2f9afdada925bd01be67a4fc07d78c0a89e8f4f5bbfff2e00c2f832d64181bd9029f4a76f0b3e8a139136cece4c6b1fb9a992bdfd7fc0bbc2f0e5c3fcae00da7a0badd2fb5051bec91f91bcff866f923c417fc5bfa25ef82a9516a3f0a79fe300a49b4e9c2c30475689bc4490bdbdbdd219e7f5483804d5");
              key_qiBytes = hexToBytes("72219d48aef06819c57cb7f29ac5bf56d08cdc41651b511db067de00d54cbb2ad5e5a8a9f17f2faa6d7e0d27cd7af1245e6e7eab8a2ea64bb8c26bd8039513ddd0654b1ee83743109160455fa782e0d1fddc888a22e5bc81f5e11ff7a536fec1b9e09a78913a742701b12842e55ab7511485c8b232d654a69c648419cbd1a876");
              evt.srcElement.form.elements["keyLength"][1].checked = true;
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert params
          const currentKey_nEnc = evt.srcElement.form.getAttribute(key_n + "CurrentEnc");
          let key_nValue = fromBytes(key_nBytes, currentKey_nEnc);
          evt.srcElement.form.elements[key_n].value = key_nValue;

          const currentKey_eEnc = evt.srcElement.form.getAttribute(key_e + "CurrentEnc");
          let key_eValue = fromBytes(key_eBytes, currentKey_eEnc);
          evt.srcElement.form.elements[key_e].value = key_eValue;

          const currentKey_dEnc = evt.srcElement.form.getAttribute(key_d + "CurrentEnc");
          let key_dValue = fromBytes(key_dBytes, currentKey_dEnc);
          evt.srcElement.form.elements[key_d].value = key_dValue;

          const currentKey_pEnc = evt.srcElement.form.getAttribute(key_p + "CurrentEnc");
          let key_pValue = fromBytes(key_pBytes, currentKey_pEnc);
          evt.srcElement.form.elements[key_p].value = key_pValue;

          const currentKey_qEnc = evt.srcElement.form.getAttribute(key_q + "CurrentEnc");
          let key_qValue = fromBytes(key_qBytes, currentKey_qEnc);
          evt.srcElement.form.elements[key_q].value = key_qValue;

          const currentKey_dpEnc = evt.srcElement.form.getAttribute(key_dp + "CurrentEnc");
          let key_dpValue = fromBytes(key_dpBytes, currentKey_dpEnc);
          evt.srcElement.form.elements[key_dp].value = key_dpValue;

          const currentKey_dqEnc = evt.srcElement.form.getAttribute(key_dq + "CurrentEnc");
          let key_dqValue = fromBytes(key_dqBytes, currentKey_dqEnc);
          evt.srcElement.form.elements[key_dq].value = key_dqValue;

          const currentKey_qiEnc = evt.srcElement.form.getAttribute(key_qi + "CurrentEnc");
          let key_qiValue = fromBytes(key_qiBytes, currentKey_qiEnc);
          evt.srcElement.form.elements[key_qi].value = key_qiValue;
        }

        function rsaData(evt, target) {
          let dataBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "hello world":
              dataBytes = toBytes("hello world", "utf-8");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(dataBytes)), currentDataEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        async function rsaCheckKey(evt, key_n, key_e, key_d, key_p, key_q, key_dp, key_dq, key_qi) {
          const alg = evt.srcElement.form.elements["alg"].value;

          let key_nBytes = toBytes(evt.srcElement.form.elements[key_n].value, evt.srcElement.form.getAttribute("key_nCurrentEnc"));
          let key_eBytes = toBytes(evt.srcElement.form.elements[key_e].value, evt.srcElement.form.getAttribute("key_eCurrentEnc"));
          let key_dBytes = toBytes(evt.srcElement.form.elements[key_d].value, evt.srcElement.form.getAttribute("key_dCurrentEnc"));
          let key_pBytes = toBytes(evt.srcElement.form.elements[key_p].value, evt.srcElement.form.getAttribute("key_pCurrentEnc"));
          let key_qBytes = toBytes(evt.srcElement.form.elements[key_q].value, evt.srcElement.form.getAttribute("key_qCurrentEnc"));
          let key_dpBytes = toBytes(evt.srcElement.form.elements[key_dp].value, evt.srcElement.form.getAttribute("key_dpCurrentEnc"));
          let key_dqBytes = toBytes(evt.srcElement.form.elements[key_dq].value, evt.srcElement.form.getAttribute("key_dqCurrentEnc"));
          let key_qiBytes = toBytes(evt.srcElement.form.elements[key_qi].value, evt.srcElement.form.getAttribute("key_qiCurrentEnc"));

          // create key pair structure
          let keyPair = {
            "alg": "PS" + alg.substring(4),
            "n": bytesToBase64Url(key_nBytes),
            "e": bytesToBase64Url(key_eBytes),
            "d": bytesToBase64Url(key_dBytes),
            "p": bytesToBase64Url(key_pBytes),
            "q": bytesToBase64Url(key_qBytes),
            "dp": bytesToBase64Url(key_dpBytes),
            "dq": bytesToBase64Url(key_dqBytes),
            "qi": bytesToBase64Url(key_qiBytes),
            "ext": true,
            "key_ops": ["sign", "verify"],
            "kty": "RSA",
          };

          let isValid = true;

          // check private key import
          const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "RSA-PSS",
              hash: {name: alg}
            },
            true,
            ["sign"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("rsaTab", 0, "<b>error</b>: " + err);
          });

          // check public key import
          delete keyPair['d']; // must be removed
          let publicKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "RSA-PSS",
              hash: {name: alg}
            },
            true,
            ["verify"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("rsaTab", 0, "<b>error</b>: " + err);
          });

          if (isValid) {
            setStatus("rsaTab", 0, "<b>status</b>: ok");
          }
        }

        async function rsa(evt) {
          const alg = evt.srcElement.form.elements["alg"].value;

          let key_nBytes = toBytes(evt.srcElement.form.elements["key_n"].value, evt.srcElement.form.getAttribute("key_nCurrentEnc"));
          let key_eBytes = toBytes(evt.srcElement.form.elements["key_e"].value, evt.srcElement.form.getAttribute("key_eCurrentEnc"));
          let key_dBytes = toBytes(evt.srcElement.form.elements["key_d"].value, evt.srcElement.form.getAttribute("key_dCurrentEnc"));
          let key_pBytes = toBytes(evt.srcElement.form.elements["key_p"].value, evt.srcElement.form.getAttribute("key_pCurrentEnc"));
          let key_qBytes = toBytes(evt.srcElement.form.elements["key_q"].value, evt.srcElement.form.getAttribute("key_qCurrentEnc"));
          let key_dpBytes = toBytes(evt.srcElement.form.elements["key_dp"].value, evt.srcElement.form.getAttribute("key_dpCurrentEnc"));
          let key_dqBytes = toBytes(evt.srcElement.form.elements["key_dq"].value, evt.srcElement.form.getAttribute("key_dqCurrentEnc"));
          let key_qiBytes = toBytes(evt.srcElement.form.elements["key_qi"].value, evt.srcElement.form.getAttribute("key_qiCurrentEnc"));

          if (evt.srcElement.value == "sign") {
            const currentSgnEnc = evt.srcElement.form.getAttribute("sgnCurrentEnc");
            const dataBytes = toBytes(evt.srcElement.form.elements["data"].value, evt.srcElement.form.getAttribute("dataCurrentEnc"));
            if (key_nBytes == null || key_eBytes == null || key_dBytes == null || key_pBytes == null || key_qBytes == null ||
                key_dpBytes == null || key_dqBytes == null || key_qiBytes == null || dataBytes == null) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("rsaTab", 1, "<b>error</b>: bad input data");
              return;
            }
            // create key pair structure
            let keyPair = {
              "alg": "PS" + alg.substring(4),
              "n": bytesToBase64Url(key_nBytes),
              "e": bytesToBase64Url(key_eBytes),
              "d": bytesToBase64Url(key_dBytes),
              "p": bytesToBase64Url(key_pBytes),
              "q": bytesToBase64Url(key_qBytes),
              "dp": bytesToBase64Url(key_dpBytes),
              "dq": bytesToBase64Url(key_dqBytes),
              "qi": bytesToBase64Url(key_qiBytes),
              "ext": true,
              "key_ops": ["sign", "verify"],
              "kty": "RSA",
            };

            // private key import
            const privateKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPair,
              {
                name: "RSA-PSS",
                hash: {name: alg}
              },
              true,
              ["sign"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("rsaTab", 1, "<b>error</b>: " + err);
            });

            window.crypto.subtle.sign(
              {
                name: "RSA-PSS",
                saltLength: 20
              },
              privateKey,
              bytesToUint8Array(dataBytes)
            ).then(function(rsa) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(rsa)), currentSgnEnc);
              evt.srcElement.form.elements["sgn"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("rsaTab", 1, "<b>error</b>: " + err);
            });
          } else if (evt.srcElement.value == "verify") {
            const currentSgnEnc = evt.srcElement.form.getAttribute("sgnCurrentEnc");
            const dataBytes = toBytes(evt.srcElement.form.elements["data"].value, evt.srcElement.form.getAttribute("dataCurrentEnc"));
            if (key_nBytes == null || key_eBytes == null || dataBytes == null) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("rsaTab", 1, "<b>error</b>: bad input data");
              return;
            }
            let sgnBytes = toBytes(evt.srcElement.form.elements["sgn"].value, currentSgnEnc);
            // create public key structure
            const keyPub = {
              "alg": "PS" + alg.substring(4),
              "n": bytesToBase64Url(key_nBytes),
              "e": bytesToBase64Url(key_eBytes),
              "ext": true,
              "key_ops": ["verify"],
              "kty": "RSA",
            };

            const publicKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPub,
              {
                name: "RSA-PSS",
                hash: {name: alg}
              },
              true,
              ["verify"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              setStatus("rsaTab", 1, "<b>error</b>: " + err);
            });

            window.crypto.subtle.verify(
              {
                name: "RSA-PSS",
                saltLength: 20
              },
              publicKey,
              bytesToUint8Array(sgnBytes),
              bytesToUint8Array(dataBytes)
            ).then(function(isvalid) {
              setStatus("rsaTab", 1, "<b>status</b>: " + isvalid);
            }).catch(function(err) {
              setStatus("rsaTab", 1, "<b>error</b>: " + err);
            });
          } else if (evt.srcElement.value == "encrypt") {
            const currentOutputEnc = evt.srcElement.form.getAttribute("outputCurrentEnc");
            const inputBytes = toBytes(evt.srcElement.form.elements["input"].value, evt.srcElement.form.getAttribute("inputCurrentEnc"));
            if (key_nBytes == null || key_eBytes == null || inputBytes == null) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("rsaTab", 2, "<b>error</b>: bad input data");
              return;
            }
            // create public key structure
            const keyPub = {
              "alg": "RSA-OAEP-" + alg.substring(4),
              "n": bytesToBase64Url(key_nBytes),
              "e": bytesToBase64Url(key_eBytes),
              "ext": true,
              "key_ops": ["encrypt"],
              "kty": "RSA",
            };

            const publicKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPub,
              {
                name: "RSA-OAEP",
                hash: {name: alg}
              },
              true,
              ["encrypt"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              setStatus("rsaTab", 2, "<b>error</b>: " + err);
            });

            window.crypto.subtle.encrypt(
              {
                name: "RSA-OAEP",
              },
              publicKey,
              bytesToUint8Array(inputBytes)
            ).then(function(encrypted) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(encrypted)), currentOutputEnc);
              evt.srcElement.form.elements["output"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("rsaTab", 2, "<b>error</b>: " + err);
            });
          } else if (evt.srcElement.value == "decrypt") {
            const currentOutputEnc = evt.srcElement.form.getAttribute("outputCurrentEnc");
            const inputBytes = toBytes(evt.srcElement.form.elements["input"].value, evt.srcElement.form.getAttribute("inputCurrentEnc"));

            if (key_nBytes == null || key_eBytes == null || key_dBytes == null || key_pBytes == null || key_qBytes == null ||
                key_dpBytes == null || key_dqBytes == null || key_qiBytes == null || inputBytes == null) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("rsaTab", 2, "<b>error</b>: bad input data");
              return;
            }

            // create key pair structure
            let keyPair = {
              "alg": "RSA-OAEP-" + alg.substring(4),
              "n": bytesToBase64Url(key_nBytes),
              "e": bytesToBase64Url(key_eBytes),
              "d": bytesToBase64Url(key_dBytes),
              "p": bytesToBase64Url(key_pBytes),
              "q": bytesToBase64Url(key_qBytes),
              "dp": bytesToBase64Url(key_dpBytes),
              "dq": bytesToBase64Url(key_dqBytes),
              "qi": bytesToBase64Url(key_qiBytes),
              "ext": true,
              "key_ops": ["decrypt"],
              "kty": "RSA",
            };

            // private key import
            const privateKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPair,
              {
                name: "RSA-OAEP",
                hash: {name: alg}
              },
              true,
              ["decrypt"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("rsaTab", 2, "<b>error</b>: " + err);
            });

            window.crypto.subtle.decrypt(
              {
                name: "RSA-OAEP",
              },
              privateKey,
              bytesToUint8Array(inputBytes)
            ).then(function(decrypted) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(decrypted)), currentOutputEnc);
              evt.srcElement.form.elements["output"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("rsaTab", 2, "<b>error</b>: " + err);
            });
          }
        }

        // initialize fields
        document.getElementById("rsa").setAttribute("key_e" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("key_n" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("key_d" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("key_p" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("key_q" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("key_dp" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("key_dq" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("key_qi" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("data" + "CurrentEnc", "utf-8");
        document.getElementById("rsa").setAttribute("sgn" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("input" + "CurrentEnc", "hex");
        document.getElementById("rsa").setAttribute("output" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="ecdsaTab" class="tabcontent">
      <form id="ecdsa">
        <p><b>EC</b>
          <input type="radio" name="curve" id="p-256" value="P-256" checked/> P-256
          <input type="radio" name="curve" id="p-384" value="P-384"/> P-384
          <input type="radio" name="curve" id="p-521" value="P-521"/> P-521
          <br/>
        </p>
        <p><b>Private key</b>
          <input type="radio" name="keyEnc" value="utf-8" onclick="switchDataEnc(event, 'key');"/> utf-8
          <input type="radio" name="keyEnc" value="hex" checked onclick="switchDataEnc(event, 'key');"/> hex
          <input type="radio" name="keyEnc" value="base64" onclick="switchDataEnc(event, 'key');" /> base64
          <input type="radio" name="keyEnc" value="base64url" onclick="switchDataEnc(event, 'key');"/> base64url
          <br/>
          <textarea id="key" rows="2"></textarea>
          <br/>
          <b>Public key</b>
          <input type="radio" name="keyPubEnc" value="utf-8" onclick="switchDataEnc(event, 'keyPub');"/> utf-8
          <input type="radio" name="keyPubEnc" value="hex" checked onclick="switchDataEnc(event, 'keyPub');"/> hex
          <input type="radio" name="keyPubEnc" value="base64" onclick="switchDataEnc(event, 'keyPub');" /> base64
          <input type="radio" name="keyPubEnc" value="base64url" onclick="switchDataEnc(event, 'keyPub');"/> base64url
          <br/>
          <textarea id="keyPub" rows="3"></textarea>
          <br/>
          <input type="button" value="clear" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="clear private" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="generate" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="key #1" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="key #2" onclick="ecdsaKey(event, 'key', 'keyPub');"/>
          <input type="button" value="x/y split" onclick="ecdsaPublicSplit(event, 'keyPub');"/>
          <input type="button" value="check" onclick="ecdsaCheckKey(event, 'key', 'keyPub');"/>
          <span class="status"></span>
        </p>
        <p><b>ECDSA</b>
          <input type="radio" name="alg" value="SHA-256" checked/> SHA-256
          <input type="radio" name="alg" value="SHA-384"/> SHA-384
          <input type="radio" name="alg" value="SHA-512"/> SHA-512
          <input type="radio" name="alg" value="SHA-1"/> SHA-1
          <br/>
        </p>
        <p><b>Data</b>
          <input type="radio" name="dataEnc" value="utf-8" checked onclick="switchDataEnc(event, 'data');"/> utf-8
          <input type="radio" name="dataEnc" value="hex" onclick="switchDataEnc(event, 'data');"/> hex
          <input type="radio" name="dataEnc" value="base64" onclick="switchDataEnc(event, 'data');"/> base64
          <input type="radio" name="dataEnc" value="base64url" onclick="switchDataEnc(event, 'data');"/> base64url
          <br/>
          <textarea id="data" rows="10"></textarea>
          <br/>
          <input type="button" value="clear" onclick="ecdsaData(event, 'data');"/>
          <input type="button" value="hello world" onclick="ecdsaData(event, 'data');"/>
        </p>
        <p>
          <input id="sign" type="button" value="sign" onclick="ecdsa(event);"/>
          <input id="verify" type="button" value="verify" onclick="ecdsa(event);"/>
        </p>
        <p>
          <b>Signature</b>
          <input type="radio" name="sgnEnc" value="utf-8" onclick="switchDataEnc(event, 'sgn');"/> utf-8
          <input type="radio" name="sgnEnc" value="hex" checked onclick="switchDataEnc(event, 'sgn');"/> hex
          <input type="radio" name="sgnEnc" value="base64" onclick="switchDataEnc(event, 'sgn');"/> base64
          <input type="radio" name="sgnEnc" value="base64url" onclick="switchDataEnc(event, 'sgn');"/> base64url
          <textarea id="sgn" rows="3"></textarea>
          <br/>
          <input type="button" value="clear" onclick="ecdsaData(event, 'sgn');"/>
          <input type="button" value="r/s split" onclick="hexSplit(event, 'sgn', -2);"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        async function ecdsaKey(evt, private, public) {
          let privateBytes = [];
          let publicBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "clear private":
              publicBytes = toBytes(evt.srcElement.form.elements[public].value, evt.srcElement.form.getAttribute("keyPubCurrentEnc"));
              break;
            case "generate":
              // generate key pair
              const curve = evt.srcElement.form.elements["curve"].value;
              const keyPair = await window.crypto.subtle.generateKey(
                {
                  name: "ECDSA",
                  namedCurve: curve
                },
                true, // is key exportable
                ["sign", "verify"]
              ).then(function(key) {
                return key;
              }).catch(function(err) {
                setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
              });

              // export private key
              privateBytes = await window.crypto.subtle.exportKey(
                "jwk",
                keyPair["privateKey"]
              ).then(function(keydata) {
                return base64UrlToBytes(keydata["d"]);
              }).catch(function(err) {
                setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
              });

              // export public key
              publicBytes = await window.crypto.subtle.exportKey(
                "raw",
                keyPair["publicKey"]
              ).then(function(keydata) {
                return uint8ArrayToBytes(new Uint8Array(keydata));
              }).catch(function(err) {
                setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
              });
              break;
            case "key #1":
              privateBytes = hexToBytes("2768f6b5a126203bcd997554030e394db197403bd5c89fb83854643e34360183");
              publicBytes = hexToBytes("04842016b1a657a6509aaab6cd069cdb79c6338c8139bca9e036037a88057b0375e7eeea10d448ea4c299da6985c3428cdc0fd9eb76bcca8ccaeae600e07339f99");
              evt.srcElement.form.elements["curve"][0].checked = true;
              break;
            case "key #2":
              privateBytes = hexToBytes("1fbd6aa212f0e71c71fe72b569611a0862f58b2714ccd541072426780a1d75b60212e09dbee808db4dfd4994598ee223");
              publicBytes = hexToBytes("04746de76853b4f38ea91fadebdc3c149e987a0e71906603199587c8a8bf3e1f94feff736004ae26966c12324bc95f74c0e59cc2b2019c56762c02cc82a8756472af447789a900ea4fd5b2231725a5b333e7d4377dec95556b5c39dc354314434d");
              evt.srcElement.form.elements["curve"][1].checked = true;
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert params
          const currentPrivateEnc = evt.srcElement.form.getAttribute(private + "CurrentEnc");
          let privateValue = fromBytes(privateBytes, currentPrivateEnc);
          evt.srcElement.form.elements[private].value = privateValue;

          const currentPublicEnc = evt.srcElement.form.getAttribute(public + "CurrentEnc");
          let publicValue = fromBytes(publicBytes, currentPublicEnc);
          evt.srcElement.form.elements[public].value = publicValue;
        }

        function ecdsaData(evt, target) {
          let dataBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "hello world":
              dataBytes = toBytes("hello world", "utf-8");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(dataBytes)), currentDataEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // split public key hex value in textarea
        function ecdsaPublicSplit(evt, target) {
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          if (currentParamEnc != "hex") {
            return;
          }
          let value = evt.srcElement.form.elements[target].value.replace(/(\s|0x)/g, "");
          let regex = new RegExp(".{2}(.{" + (value.length - 2) / 2 + "})", "g");
          evt.srcElement.form.elements[target].value = value[0] + value[1] + "\n" + value.replace(regex, "$1\n");
        }

        async function ecdsaCheckKey(evt, private, public) {
          const curve = evt.srcElement.form.elements["curve"].value;

          let privateBytes = toBytes(evt.srcElement.form.elements[private].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements[public].value, evt.srcElement.form.getAttribute("keyPubCurrentEnc"));

          // create key pair structure
          let keyPair = {
            "crv": curve,
            "d": bytesToBase64Url(privateBytes),
            "ext": true,
            "key_ops": ["sign", "verify"],
            "kty": "EC",
            "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
          };

          let isValid = true;

          // check private key import
          const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDSA",
              namedCurve: curve
            },
            true,
            ["sign"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
          });

          // check public key import
          delete keyPair['d']; // must be removed
          let publicKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDSA",
              namedCurve: curve
            },
            true,
            ["verify"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdsaTab", 0, "<b>error</b>: " + err);
          });

          if (isValid) {
            setStatus("ecdsaTab", 0, "<b>status</b>: ok");
          }
        }

        async function ecdsa(evt) {
          const alg = evt.srcElement.form.elements["alg"].value;
          const curve = evt.srcElement.form.elements["curve"].value;
          const currentSgnEnc = evt.srcElement.form.getAttribute("sgnCurrentEnc");

          let privateBytes = toBytes(evt.srcElement.form.elements["key"].value, evt.srcElement.form.getAttribute("keyCurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements["keyPub"].value, evt.srcElement.form.getAttribute("keyPubCurrentEnc"));
          let dataBytes = toBytes(evt.srcElement.form.elements["data"].value, evt.srcElement.form.getAttribute("dataCurrentEnc"));

          if (evt.srcElement.value == "sign") {
            if (privateBytes == null || publicBytes == null || dataBytes == null) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: bad input data");
              return;
            }
            // create key pair structure
            const keyPair = {
              "crv": curve,
              "d": bytesToBase64Url(privateBytes),
              "ext": true,
              "key_ops": ["sign"],
              "kty": "EC",
              "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
              "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
            };

            const privateKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPair,
              {
                name: "ECDSA",
                namedCurve: curve
              },
              true,
              ["sign"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });

            window.crypto.subtle.sign(
              {
                name: "ECDSA",
                hash: {name: alg}
              },
              privateKey,
              bytesToUint8Array(dataBytes)
            ).then(function(ecdsa) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(ecdsa)), currentSgnEnc);
              evt.srcElement.form.elements["sgn"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });
          } else {
            if (publicBytes == null || dataBytes == null) {
              evt.srcElement.form.elements["sgn"].value = "";
              setStatus("ecdsaTab", 1, "<b>error</b>: bad input data");
              return;
            }
            let sgnBytes = toBytes(evt.srcElement.form.elements["sgn"].value, currentSgnEnc);
            // create public key structure
            const keyPub = {
              "crv": curve,
              "ext": true,
              "key_ops": ["verify"],
              "kty": "EC",
              "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
              "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
            };

            const publicKey = await window.crypto.subtle.importKey(
              "jwk",
              keyPub,
              {
                name: "ECDSA",
                namedCurve: curve
              },
              true,
              ["verify"]
            ).then(function(keydata) {
              return keydata;
            }).catch(function(err) {
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });

            window.crypto.subtle.verify(
              {
                name: "ECDSA",
                hash: {name: alg}
              },
              publicKey,
              bytesToUint8Array(sgnBytes),
              bytesToUint8Array(dataBytes)
            ).then(function(isvalid) {
              setStatus("ecdsaTab", 1, "<b>status</b>: " + isvalid);
            }).catch(function(err) {
              setStatus("ecdsaTab", 1, "<b>error</b>: " + err);
            });
          }
        }

        // initialize fields
        document.getElementById("ecdsa").setAttribute("key" + "CurrentEnc", "hex");
        document.getElementById("ecdsa").setAttribute("keyPub" + "CurrentEnc", "hex");
        document.getElementById("ecdsa").setAttribute("data" + "CurrentEnc", "utf-8");
        document.getElementById("ecdsa").setAttribute("sgn" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="ecdhTab" class="tabcontent">
      <form id="ecdh">
        <p><b>EC</b>
          <input type="radio" name="curve" id="p-256" value="P-256" checked/> P-256
          <input type="radio" name="curve" id="p-384" value="P-384"/> P-384
          <input type="radio" name="curve" id="p-521" value="P-521"/> P-521
          <span class="status"></span>
        </p>
        <div id="left" style="float: left; width: 49%">
          <p><b>A Private key</b>
            <input type="radio" name="keyAEnc" value="utf-8" onclick="switchDataEnc(event, 'keyA');"/> utf-8
            <input type="radio" name="keyAEnc" value="hex" checked onclick="switchDataEnc(event, 'keyA');"/> hex
            <input type="radio" name="keyAEnc" value="base64" onclick="switchDataEnc(event, 'keyA');" /> base64
            <input type="radio" name="keyAEnc" value="base64url" onclick="switchDataEnc(event, 'keyA');"/> base64url
            <br/>
            <textarea id="keyA" rows="3"></textarea>
            <br/>
            <b>A Public key</b>
            <input type="radio" name="keyPubAEnc" value="utf-8" onclick="switchDataEnc(event, 'keyPubA');"/> utf-8
            <input type="radio" name="keyPubAEnc" value="hex" checked onclick="switchDataEnc(event, 'keyPubA');"/> hex
            <input type="radio" name="keyPubAEnc" value="base64" onclick="switchDataEnc(event, 'keyPubA');" /> base64
            <input type="radio" name="keyPubAEnc" value="base64url" onclick="switchDataEnc(event, 'keyPubA');"/> base64url
            <br/>
            <textarea id="keyPubA" rows="7"></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="generate" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="key #1" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="key #2" onclick="ecdhKey(event, 'keyA', 'keyPubA');"/>
            <input type="button" value="x/y split" onclick="ecdhPublicSplit(event, 'keyPubA');"/>
            <input type="button" value="check" onclick="ecdhCheckKey(event, 'keyA', 'keyPubA');"/>
          </p>
          <p>
            <input id="derive key" type="button" value="derive key" onclick="ecdh(event, 'keyA', 'keyPubA', 'keyPubB', 'secretA', 0);"/>
            <input id="derive bits" type="button" value="derive bits" onclick="ecdh(event, 'keyA', 'keyPubA', 'keyPubB', 'secretA', 0);"/>
            <input id="derive 512 bits" type="button" value="derive 512 bits" onclick="ecdh(event, 'keyA', 'keyPubA', 'keyPubB', 'secretA', 512);"/>
          </p>
          <p>
            <b>A Secret</b>
            <input type="radio" name="secretAEnc" value="utf-8" onclick="switchDataEnc(event, 'secretA');"/> utf-8
            <input type="radio" name="secretAEnc" value="hex" checked onclick="switchDataEnc(event, 'secretA');"/> hex
            <input type="radio" name="secretAEnc" value="base64" onclick="switchDataEnc(event, 'secretA');"/> base64
            <input type="radio" name="secretAEnc" value="base64url" onclick="switchDataEnc(event, 'secretA');"/> base64url
            <textarea id="secretA" rows="3" readonly></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhData(event, 'secretA');"/>
          </p>
        </div>
        <div id="right" style="float: right; width: 49%">
          <p><b>B Private key</b>
            <input type="radio" name="keyBEnc" value="utf-8" onclick="switchDataEnc(event, 'keyB');"/> utf-8
            <input type="radio" name="keyBEnc" value="hex" checked onclick="switchDataEnc(event, 'keyB');"/> hex
            <input type="radio" name="keyBEnc" value="base64" onclick="switchDataEnc(event, 'keyB');" /> base64
            <input type="radio" name="keyBEnc" value="base64url" onclick="switchDataEnc(event, 'keyB');"/> base64url
            <br/>
            <textarea id="keyB" rows="3"></textarea>
            <br/>
            <b>B Public key</b>
            <input type="radio" name="keyPubBEnc" value="utf-8" onclick="switchDataEnc(event, 'keyPubB');"/> utf-8
            <input type="radio" name="keyPubBEnc" value="hex" checked onclick="switchDataEnc(event, 'keyPubB');"/> hex
            <input type="radio" name="keyPubBEnc" value="base64" onclick="switchDataEnc(event, 'keyPubB');" /> base64
            <input type="radio" name="keyPubBEnc" value="base64url" onclick="switchDataEnc(event, 'keyPubB');"/> base64url
            <br/>
            <textarea id="keyPubB" rows="7"></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="generate" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="key #1" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="key #2" onclick="ecdhKey(event, 'keyB', 'keyPubB');"/>
            <input type="button" value="x/y split" onclick="ecdhPublicSplit(event, 'keyPubB');"/>
            <input type="button" value="check" onclick="ecdhCheckKey(event, 'keyB', 'keyPubB');"/>
          </p>
          <p>
            <input id="derive key" type="button" value="derive key" onclick="ecdh(event, 'keyB', 'keyPubB', 'keyPubA', 'secretB', 0);"/>
            <input id="derive bits" type="button" value="derive bits" onclick="ecdh(event, 'keyB', 'keyPubB', 'keyPubA', 'secretB', 0);"/>
            <input id="derive 512 bits" type="button" value="derive 512 bits" onclick="ecdh(event, 'keyB', 'keyPubB', 'keyPubA', 'secretB', 512);"/>
          </p>
          <p>
            <b>B Secret</b>
            <input type="radio" name="secretBEnc" value="utf-8" onclick="switchDataEnc(event, 'secretB');"/> utf-8
            <input type="radio" name="secretBEnc" value="hex" checked onclick="switchDataEnc(event, 'secretB');"/> hex
            <input type="radio" name="secretBEnc" value="base64" onclick="switchDataEnc(event, 'secretB');"/> base64
            <input type="radio" name="secretBEnc" value="base64url" onclick="switchDataEnc(event, 'secretB');"/> base64url
            <textarea id="secretB" rows="3" readonly></textarea>
            <br/>
            <input type="button" value="clear" onclick="ecdhData(event, 'secretB');"/>
          </p>
        </div>
      </form>

      <script>
        async function ecdhKey(evt, private, public) {
          let privateBytes = [];
          let publicBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "generate":
              // generate key pair
              const curve = evt.srcElement.form.elements["curve"].value;
              const keyPair = await window.crypto.subtle.generateKey(
                {
                  name: "ECDH",
                  namedCurve: curve
                },
                true, // is key exportable
                ["deriveKey", "deriveBits"]
              ).then(function(key) {
                return key;
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });

              // export private key
              privateBytes = await window.crypto.subtle.exportKey(
                "jwk",
                keyPair["privateKey"]
              ).then(function(keydata) {
                return base64UrlToBytes(keydata["d"]);
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });

              // export public key
              publicBytes = await window.crypto.subtle.exportKey(
                "raw",
                keyPair["publicKey"]
              ).then(function(keydata) {
                return uint8ArrayToBytes(new Uint8Array(keydata));
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });
              break;
            case "key #1":
              privateBytes = hexToBytes("2768f6b5a126203bcd997554030e394db197403bd5c89fb83854643e34360183");
              publicBytes = hexToBytes("04842016b1a657a6509aaab6cd069cdb79c6338c8139bca9e036037a88057b0375e7eeea10d448ea4c299da6985c3428cdc0fd9eb76bcca8ccaeae600e07339f99");
              evt.srcElement.form.elements["curve"][0].checked = true;
              break;
            case "key #2":
              privateBytes = hexToBytes("1fbd6aa212f0e71c71fe72b569611a0862f58b2714ccd541072426780a1d75b60212e09dbee808db4dfd4994598ee223");
              publicBytes = hexToBytes("04746de76853b4f38ea91fadebdc3c149e987a0e71906603199587c8a8bf3e1f94feff736004ae26966c12324bc95f74c0e59cc2b2019c56762c02cc82a8756472af447789a900ea4fd5b2231725a5b333e7d4377dec95556b5c39dc354314434d");
              evt.srcElement.form.elements["curve"][1].checked = true;
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert params
          const currentPrivateEnc = evt.srcElement.form.getAttribute(private + "CurrentEnc");
          let privateValue = fromBytes(privateBytes, currentPrivateEnc);
          evt.srcElement.form.elements[private].value = privateValue;

          const currentPublicEnc = evt.srcElement.form.getAttribute(public + "CurrentEnc");
          let publicValue = fromBytes(publicBytes, currentPublicEnc);
          evt.srcElement.form.elements[public].value = publicValue;
        }

        function ecdhData(evt, target) {
          let dataBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "hello world":
              dataBytes = toBytes("hello world", "utf-8");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(dataBytes)), currentDataEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        // split public key hex value in textarea
        function ecdhPublicSplit(evt, target) {
          const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          if (currentParamEnc != "hex") {
            return;
          }
          let value = evt.srcElement.form.elements[target].value.replace(/(\s|0x)/g, "");
          let regex = new RegExp(".{2}(.{" + (value.length - 2) / 2 + "})", "g");
          evt.srcElement.form.elements[target].value = value[0] + value[1] + "\n" + value.replace(regex, "$1\n");
        }

        async function ecdhCheckKey(evt, private, public) {
          const curve = evt.srcElement.form.elements["curve"].value;

          let privateBytes = toBytes(evt.srcElement.form.elements[private].value, evt.srcElement.form.getAttribute(private + "CurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements[public].value, evt.srcElement.form.getAttribute(public + "CurrentEnc"));

          // create key pair structure
          let keyPair = {
            "crv": curve,
            "d": bytesToBase64Url(privateBytes),
            "ext": true,
            "key_ops": ["deriveKey", "deriveBits"],
            "kty": "EC",
            "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
          };

          let isValid = true;

          // check private key import
          const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            ["deriveKey", "deriveBits"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          // check public key import
          delete keyPair['d']; // must be removed
          let publicKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            []
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            isValid = false;
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          if (isValid) {
            setStatus("ecdhTab", 0, "<b>status</b>: ok");
          }
        }

        async function ecdh(evt, private, public, public2, secret, bits) {
          const curve = evt.srcElement.form.elements["curve"].value;
          const currentSecretEnc = evt.srcElement.form.getAttribute(secret + "CurrentEnc");

          let privateBytes = toBytes(evt.srcElement.form.elements[private].value, evt.srcElement.form.getAttribute(private + "CurrentEnc"));
          let publicBytes = toBytes(evt.srcElement.form.elements[public].value, evt.srcElement.form.getAttribute(public + "CurrentEnc"));
          let public2Bytes = toBytes(evt.srcElement.form.elements[public2].value, evt.srcElement.form.getAttribute(public2 + "CurrentEnc"));

          if (privateBytes == null || publicBytes == null || public2Bytes == null) {
            evt.srcElement.form.elements[secret].value = "";
            setStatus("ecdhTab", 0, "<b>error</b>: bad input data");
            return;
          }

          // create key pair structure
          const keyPair = {
            "crv": curve,
            "d": bytesToBase64Url(privateBytes),
            "ext": true,
            "key_ops": ["deriveKey", "deriveBits"],
            "kty": "EC",
            "x": bytesToBase64Url(publicBytes.slice(1, (publicBytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(publicBytes.slice(publicBytes.length - (publicBytes.length - 1) / 2), publicBytes.length) // y part
          };

          const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            keyPair,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            ["deriveKey", "deriveBits"]
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            evt.srcElement.form.elements[secret].value = "";
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          // create public key structure
          const keyPub = {
            "crv": curve,
            "ext": true,
            "key_ops": ["verify"],
            "kty": "EC",
            "x": bytesToBase64Url(public2Bytes.slice(1, (public2Bytes.length - 1) / 2 + 1)), // x part, 04 removed
            "y": bytesToBase64Url(public2Bytes.slice(public2Bytes.length - (public2Bytes.length - 1) / 2), public2Bytes.length) // y part
          };

          const public2Key = await window.crypto.subtle.importKey(
            "jwk",
            keyPub,
            {
              name: "ECDH",
              namedCurve: curve
            },
            true,
            []
          ).then(function(keydata) {
            return keydata;
          }).catch(function(err) {
            setStatus("ecdhTab", 0, "<b>error</b>: " + err);
          });

          if (bits == 0) {
            bits = ((publicBytes.length - 1) / 2) * 8;
          }

          if (evt.srcElement.value.search("bits") != -1) {
            window.crypto.subtle.deriveBits(
              {
                name: "ECDH",
                namedCurve: curve,
                public: public2Key,
              },
              privateKey,
              bits // number of bits to derive, max one coordinate
            ).then(function(bits) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(bits)), currentSecretEnc);
              evt.srcElement.form.elements[secret].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements[secret].value = "";
              setStatus("ecdhTab", 0, "<b>error</b>: " + err);
            });
          } else {
            window.crypto.subtle.deriveKey(
              {
                name: "ECDH",
                namedCurve: curve,
                public: public2Key,
              },
              privateKey,
              {
                name: "AES-CBC",
                length: 128,
              },
              true,
              ["encrypt", "decrypt"]
            ).then(function(keydata) {
              // export key
              window.crypto.subtle.exportKey(
                "raw",
                keydata
              ).then(function(keydata) {
                let value = fromBytes(uint8ArrayToBytes(new Uint8Array(keydata)), currentSecretEnc);
                evt.srcElement.form.elements[secret].value = value;
              }).catch(function(err) {
                setStatus("ecdhTab", 0, "<b>error</b>: " + err);
              });
            }).catch(function(err) {
              evt.srcElement.form.elements[secret].value = "";
              setStatus("ecdhTab", 0, "<b>error</b>: " + err);
            });
          }
        }

        // initialize fields
        document.getElementById("ecdh").setAttribute("keyA" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("keyPubA" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("keyB" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("keyPubB" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("secretA" + "CurrentEnc", "hex");
        document.getElementById("ecdh").setAttribute("secretB" + "CurrentEnc", "hex");
      </script>
    </div>

    <div id="pbkdf2Tab" class="tabcontent">
      <form id="pbkdf2">
        <p><b>Password</b>
          <input type="radio" name="passEnc" value="utf-8" checked onclick="switchDataEnc(event, 'pass');"/> utf-8
          <input type="radio" name="passEnc" value="hex" onclick="switchDataEnc(event, 'pass');"/> hex
          <input type="radio" name="passEnc" value="base64" onclick="switchDataEnc(event, 'pass');" /> base64
          <input type="radio" name="passEnc" value="base64url" onclick="switchDataEnc(event, 'pass');"/> base64url
          <br/>
          <textarea id="pass" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="pbkdf2Data(event, 'pass');"/>
          <input type="button" value="password" onclick="pbkdf2Data(event, 'pass');"/>
        </p>
        <p><b>HMAC</b>
          <input type="radio" name="alg" value="SHA-256" checked/> SHA-256
          <input type="radio" name="alg" value="SHA-384"/> SHA-384
          <input type="radio" name="alg" value="SHA-512"/> SHA-512
          <input type="radio" name="alg" value="SHA-1"/> SHA-1
          <br/>
        </p>
        <p><b>Salt</b>
          <input type="radio" name="saltEnc" value="utf-8" onclick="switchDataEnc(event, 'salt');"/> utf-8
          <input type="radio" name="saltEnc" value="hex" checked onclick="switchDataEnc(event, 'salt');"/> hex
          <input type="radio" name="saltEnc" value="base64" onclick="switchDataEnc(event, 'salt');"/> base64
          <input type="radio" name="saltEnc" value="base64url" onclick="switchDataEnc(event, 'salt');"/> base64url
          <br/>
          <textarea id="salt" rows="2"></textarea>
          <br/>
          <input type="button" value="clear" onclick="pbkdf2Data(event, 'salt');"/>
          <input type="button" value="128 bit" onclick="pbkdf2Data(event, 'salt');"/>
          <input type="button" value="256 bit" onclick="pbkdf2Data(event, 'salt');"/>
          <input type="button" value="salt #1" onclick="pbkdf2Data(event, 'salt');"/>
          <input type="button" value="salt #2" onclick="pbkdf2Data(event, 'salt');"/>
        </p>
        <p><b>Iterations: <span id="pbkdf2Iterations">256000</span></b><br/>
          <input type="range" id="iterations" name="shares" min="1" max="1000000" step="1" value="256000" style="width: 100%" oninput="pbkdf2UpdateValue(event);"/>
        </p>
        <p>
          <input id="derive key" type="button" value="derive key" onclick="pbkdf2(event, 0);"/>
          <input id="derive bits" type="button" value="derive bits" onclick="pbkdf2(event, 0);"/>
          <input id="derive 512 bits" type="button" value="derive 512 bits" onclick="pbkdf2(event, 512);"/>
        </p>
        <p><b>Output</b>
          <input type="radio" name="outputEnc" value="utf-8" onclick="switchDataEnc(event, 'output');"/> utf-8
          <input type="radio" name="outputEnc" value="hex" checked onclick="switchDataEnc(event, 'output');"/> hex
          <input type="radio" name="outputEnc" value="base64" onclick="switchDataEnc(event, 'output');"/> base64
          <input type="radio" name="outputEnc" value="base64url" onclick="switchDataEnc(event, 'output');"/> base64url
          <textarea id="output" rows="3" readonly></textarea>
          <br/>
          <input type="button" value="clear" onclick="pbkdf2Data(event, 'output');"/>
          <span class="status"></span>
        </p>
      </form>

      <script>
        function pbkdf2Data(evt, target) {
          let dataBytes = [];
          switch (evt.srcElement.value) {
            case "clear":
              break;
            case "password":
              dataBytes = toBytes("password", "utf-8");
              break;
            case "128 bit":
              dataBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(16)));
              break;
            case "256 bit":
              dataBytes = uint8ArrayToBytes(window.crypto.getRandomValues(new Uint8Array(32)));
              break;
            case "salt #1":
              dataBytes = hexToBytes("8eda45b24ce3a0adb96448562f7dcc9a");
              break;
            case "salt #2":
              dataBytes = hexToBytes("6fb2d9a935e7751eaeb88026ce0ce0f6c2dc22a0b9b0d5e52af261570b1cb7a9");
              break;
            default:
              console.log("Event not supported: " + evt.srcElement.value);
              break;
          }

          // convert param
          const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
          let value = fromBytes(uint8ArrayToBytes(new Uint8Array(dataBytes)), currentDataEnc);
          evt.srcElement.form.elements[target].value = value;
        }

        async function pbkdf2(evt, bits) {
          const alg = evt.srcElement.form.elements["alg"].value;
          const currentOutputEnc = evt.srcElement.form.getAttribute("outputCurrentEnc");
          const iterations = evt.srcElement.form.elements["iterations"].value;

          const passBytes = toBytes(evt.srcElement.form.elements["pass"].value, evt.srcElement.form.getAttribute("passCurrentEnc"));
          const saltBytes = toBytes(evt.srcElement.form.elements["salt"].value, evt.srcElement.form.getAttribute("saltCurrentEnc"));

          if (passBytes == null || saltBytes == null) {
            evt.srcElement.form.elements["output"].value = "";
            setStatus("pbkdf2Tab", 0, "<b>error</b>: bad input data");
            return;
          }

          const pbkdf2Key = await window.crypto.subtle.importKey(
            "raw",
            bytesToUint8Array(passBytes), // password
            {
              name: "PBKDF2",
            },
            false,
            ["deriveKey", "deriveBits"]
          ).then(function(key) {
            return key;
          }).catch(function(err) {
            evt.srcElement.form.elements["output"].value = "";
            setStatus("pbkdf2Tab", 0, "<b>error</b>: " + err);
          });

          if (pbkdf2Key == null) {
            return;
          }

          if (bits == 0) {
            switch (alg) {
              case "SHA-256":
                bits=256;
                break;
              case "SHA-384":
                bits=384;
                break;
              case "SHA-512":
                bits=512;
                break;
              case "SHA-1":
                bits=160;
                break;
            }
          }

          if (evt.srcElement.value.search("bits") != -1) {
            window.crypto.subtle.deriveBits(
              {
                "name": "PBKDF2",
                salt: bytesToUint8Array(saltBytes),
                iterations: iterations,
                hash: {name: alg}
              },
              pbkdf2Key,
              bits //the number of bits you want to derive
            ).then(function(bits) {
              let value = fromBytes(uint8ArrayToBytes(new Uint8Array(bits)), currentOutputEnc);
              evt.srcElement.form.elements["output"].value = value;
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("pbkdf2Tab", 0, "<b>error</b>: " + err);
            });
          } else {
            window.crypto.subtle.deriveKey(
              {
                "name": "PBKDF2",
                salt: bytesToUint8Array(saltBytes),
                iterations: iterations,
                hash: {name: alg}
              },
              pbkdf2Key,
              {
                name: "AES-CBC",
                length: 128,
              },
              true,
              ["encrypt", "decrypt"]
            ).then(function(keydata) {
              // export key
              window.crypto.subtle.exportKey(
                "raw",
                keydata
              ).then(function(keydata) {
                let value = fromBytes(uint8ArrayToBytes(new Uint8Array(keydata)), currentOutputEnc);
                evt.srcElement.form.elements["output"].value = value;
              }).catch(function(err) {
                setStatus("pbkdf2Tab", 0, "<b>error</b>: " + err);
              });
            }).catch(function(err) {
              evt.srcElement.form.elements["output"].value = "";
              setStatus("pbkdf2Tab", 0, "<b>error</b>: " + err);
            });
          }
        }

        // update iterations from input range
        function pbkdf2UpdateValue(evt) {
          document.getElementById("pbkdf2Tab").querySelector("#pbkdf2Iterations").innerHTML = evt.srcElement.value;
        }

        // initialize fields
        document.getElementById("pbkdf2").setAttribute("pass" + "CurrentEnc", "utf-8");
        document.getElementById("pbkdf2").setAttribute("salt" + "CurrentEnc", "hex");
        document.getElementById("pbkdf2").setAttribute("output" + "CurrentEnc", "hex");
      </script>
    </div>

    <script>
      // common functions

      // remove spaces/0x and convert a hex string to a byte array
      function hexToBytes(hex) {
        hex = hex.replace(/(\s|0x)/g, "");
        let reg=/^([0-9a-f]{2})*$/i;
        if (!reg.test(hex)) {
          return null;
        }

        let bytes = [];
        for (bytes = [], c = 0; c < hex.length; c += 2) {
          bytes.push(parseInt(hex.substr(c, 2), 16));
        }
        return bytes;
      }

      // convert a byte array to a hex string and decorate it with new lines, spaces and prefixes
      function bytesToHex(bytes, newline = 0, space = 0, prefix = "") {
        let hex = [];
        for (hex = [], i = 0; i < bytes.length; i++) {
          let current = bytes[i] < 0 ? bytes[i] + 256 : bytes[i];
          hex.push((current >>> 4).toString(16));
          hex.push((current & 0xF).toString(16));
        }
        hex = hex.join("");
        if (space == 0 && newline == 0) {
          hex = prefix + hex;
        }
        if (space != 0) {
          let regex = new RegExp("(.{" + space + "})", "g");
          hex = hex.replace(regex, "$1 " + prefix); // add spaces and prefix
          hex = hex.substring(0, hex.length - (1 + prefix.length)); // remove last occurence
          hex = prefix + hex; // add prefix at begining
        }
        if (newline != 0) {
          let regex;
          if (space == 0) {
            regex = new RegExp("(.{" + newline + "})", "g");
            hex = hex.replace(regex, "$1\n" + prefix); // add newline and prefix
            hex = hex.substring(0, hex.length - (1 + prefix.length)); // remove last occurence
            hex = prefix + hex; // add prefix at begining
          } else {
            let fix = newline + (newline / space) * (1 + prefix.length) - 1; // fix newline value
            regex = new RegExp("(.{" + fix + "}) ", "g");
            hex = hex.replace(regex, "$1\n"); // add newlines
          }
        }
        return hex;
      }

      // convert a byte array to base64 url string
      function bytesToBase64Url(bytes) {
        try {
          return btoa(Array.from(new Uint8Array(bytes)).map(val => {
            return String.fromCharCode(val);
          }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        }
        catch(err) {
          return null;
        }
      }

      // convert a base64 url string to byte array
      function base64UrlToBytes(base64url) {
        try {
          return atob(base64url.replace(/-/g, '+').replace(/_/g, '/')).split('').map(val => {
            return val.charCodeAt(0);
          });
        }
        catch(err) {
          return null;
        }
      }

      // convert a byte array to base64 string
      function bytesToBase64(bytes) {
        try {
          return btoa(Array.from(new Uint8Array(bytes)).map(val => {
            return String.fromCharCode(val);
          }).join(''));
        }
        catch(err) {
          return null;
        }
      }

      // convert a base64 string to byte array
      function base64ToBytes(base64) {
        try {
          return atob(base64).split('').map(val => {
            return val.charCodeAt(0);
          });
        }
        catch(err) {
          return null;
        }
      }

      // convert a byte array to Uint8Array
      function bytesToUint8Array(bytes) {
        return new Uint8Array(bytes);
      }

      // convert a Uint8Array byte array to Uint8Array
      function uint8ArrayToBytes(uint8Array) {
        return [].slice.call(uint8Array);
      }

      // convert value to bytes from given encoding
      function toBytes(value, encoding) {
        if (value == null) {
          return [];
        }
        let bytes = [];
        switch (encoding) {
          case "utf-8":
            bytes = uint8ArrayToBytes(new TextEncoder("utf-8").encode(value));
            break;
          case "hex":
            bytes = hexToBytes(value);
            break;
          case "base64":
            bytes = base64ToBytes(value);
            break;
          case "base64url":
            bytes = base64UrlToBytes(value);
            break;
        }
        return bytes;
      }

      // convert bytes to value using given encoding
      function fromBytes(bytes, encoding) {
        if (bytes == null) {
          return "";
        }
        let value;
        switch (encoding) {
          case "utf-8":
            value = new TextDecoder("utf-8").decode(bytesToUint8Array(bytes));
            break;
          case "hex":
            value = bytesToHex(bytes);
            break;
          case "base64":
            value = bytesToBase64(bytes);
            break;
          case "base64url":
            value = bytesToBase64Url(bytes);
            break;
        }
        return value;
      }

      // xor two buffers, input must be larger than key buffer
      function xorBytes(input, key) {
        let output = [];
        for (let i = 0; i < input.length; i++) {
          output.push(input[i] ^ key[i % key.length]);
        }
        return output;
      }

      // convert data in target field, if CurrentEnc isn't set utf-8 as default is used
      function switchDataEnc(evt, target, forceCurrentEnc = null, forceTargetEnc = null) {
        let currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
        if (currentDataEnc == null) {
          currentDataEnc = "utf-8";
        }
        if (forceCurrentEnc != null) {
          currentDataEnc = forceCurrentEnc;
        }

        let targetDataEnc = evt.srcElement.value;
        if (forceTargetEnc != null) {
          targetDataEnc = forceTargetEnc;
        }

        if (currentDataEnc == targetDataEnc) {
          return;
        }

        console.log(currentDataEnc + " -> " + targetDataEnc);

        let value = evt.srcElement.form.elements[target].value;
        console.log("Current value: " + value);
        let bytes = toBytes(value, currentDataEnc);
        console.log("Bytes: " + bytes);
        value = fromBytes(bytes, targetDataEnc);
        console.log("Target value: " + value);
        evt.srcElement.form.elements[target].value = value;

        evt.srcElement.form.setAttribute(target + "CurrentEnc", targetDataEnc);
      }

      // truncate data to given length
      function truncData(evt, target, length) {
        const currentDataEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");

        let value = evt.srcElement.form.elements[target].value;
        console.log("Current value: " + value);
        let bytes = toBytes(value, currentDataEnc);
        console.log("Bytes: " + bytes);
        bytes = bytes.slice(0, length);
        value = fromBytes(bytes, currentDataEnc);
        console.log("Target value: " + value);
        evt.srcElement.form.elements[target].value = value;
      }

      // split hex value in textarea with block-size blocks
      // negative block value means parts (-2 = two parts)
      function hexSplit(evt, target, block) {
        const currentParamEnc = evt.srcElement.form.getAttribute(target + "CurrentEnc");
        if (currentParamEnc != "hex") {
          return;
        }
        let value = evt.srcElement.form.elements[target].value.replace(/(\s|0x)/g, "");
        if (block < 0) {
          block = value.length / 2 / (-block);
        }
        let regex = new RegExp("(.{" + 2*block + "})", "g");
        evt.srcElement.form.elements[target].value = value.replace(regex, "$1\n");
      }

      // show given tab
      function showTab(evt, tabLabel) {
        let i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
          tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
          tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(tabLabel).style.display = "block";
        if (evt != null) {
          evt.currentTarget.className += " active";
        }
      }

      function setStatus(tab, statusId, text) {
        document.getElementById(tab).getElementsByClassName("status")[statusId].innerHTML = text;
        window.setTimeout(function() {
          document.getElementById(tab).getElementsByClassName("status")[statusId].innerHTML = "";
        }, 3000);
      }

    </script>

  </body>
</html>
